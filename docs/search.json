[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Sistemas de Información Geográfica en R",
    "section": "",
    "text": "Bienvenida\nEste es un curso introductorio al procesamiento de datos geográficos mediante el lenguaje de programación R. También se estudian herramientas para facilitar la reproducibilidad de los procedimientos y la comunicación de las soluciones a través de Internet y otros medios.\nLos estudiantes no requieren experiencia previa en programación de computadoras. Se recomienda que cuenten con conocimentos básicos de datos geoespaciales y sistemas de información geográfica.\nEl enfoque del curso es teórico-práctico, con lecciones magistrales combinadas con ejercicios de programación en las que los estudiantes aplican en diversos escenarios de procesamiento de datos las habilidades y conocimientos aprendidos. Tanto las lecciones teóricas como las prácticas se imparten virtualmente.\nAdemás de este sitio, los contenidos del curso y los recursos relacionados se comparten en la plataforma UCR Global de la Universidad de Costa Rica.\nEste curso forma parte del Programa de Capacitación, Actualización y Divulgación de la Escuela de Geografía (PROCADI), iniciativa orientada a fortalecer el vínculo entre la universidad y la sociedad mediante la extensión docente.\n\n\nObjetivos\nAl finalizar el curso, el estudiantado será capaz de:\n\nAplicar el pensamiento computacional para resolver problemas mediante el lenguaje de programación R.\nUtilizar un enfoque de ciencia de datos para importar, procesar y visualizar datos.\nDesarrollar soluciones reproducibles a problemas computacionales.\nProgramar gráficos estadísticos.\nProcesar datos geográficos.\nDesarrollar documentos y aplicaciones interactivas que incluyan visualizaciones como tablas, gráficos estadísticos y mapas, entre otras.\n\n\n\nPrograma\nPrograma del curso\n\n\nInformación de contacto\nSi tiene alguna pregunta o comentario sobre este curso, por favor contacte a:\n\nManuel Vargas - manuel.vargas_d@ucr.ac.cr\nProfesor\nUniversidad de Costa Rica,\nCiudad Universitaria Rodrigo Facio,\nSan Pedro de Montes de Oca,\nCosta Rica.\n\nLos contenidos de este curso, a menos que se especifique de otra forma, se comparten mediante una licencia de Creative Commons Reconocimiento-CompartirIgual 4.0 Internacional.",
    "crumbs": [
      "Bienvenida"
    ]
  },
  {
    "objectID": "01-introduccion-programacion-computadoras.html",
    "href": "01-introduccion-programacion-computadoras.html",
    "title": "1  Introducción a la programación de computadoras",
    "section": "",
    "text": "1.1 Resumen\nEn este capítulo se explica la característica principal de las computadoras: su capacidad para ser programadas y así ayudar a resolver problemas. Se detallan los componentes físicos de la arquitectura que sustenta esta capacidad, la forma en que trabajan los lenguajes de programación, así como los principios del pensamiento computacional, un enfoque para la resolución de problemas basado en conceptos y métodos de las ciencias de la computación. Estos principios se ilustran con el lenguaje de programación Scratch.\nUna computadora es una máquina que ejecuta secuencias de instrucciones. Estas secuencias se denominan programas. La capacidad que tienen las computadoras de ser programadas permite modificar su funcionamiento sin necesidad de alterar sus componentes físicos, por lo que pueden ayudar a resolver una gran cantidad de problemas. Como paso previo a la elaboración de un programa, se acostumbra especificar la secuencia de pasos que lo componen en un algoritmo, el cual se expresa en lenguaje natural o en un diagrama. Los algoritmos y los programas reciben datos de entrada, los procesan y generan salidas.\nLas computadoras modernas están construídas con base en circuitos integrados, también llamados chips o microchips. Los circuitos integrados procesan información digital (que usa valores discretos), la cual generalmente es binaria (i.e. de dos valores). Los circuitos integrados de una computadora procesan dos estados correspondientes a dos niveles de tensión eléctrica: alto y bajo. Estos estados se representan con 0 y 1. Esto facilita la aplicación de la teoría de la información y del álgebra booleana.\nDurante el período entre las guerras mundiales, Allan Turing desarrolló la máquina de Turing, un dispositivo teórico que manipula símbolos de una cinta de acuerdo con una tabla de reglas. La máquina de Turing simula el funcionamiento de un algoritmo y los conceptos de entrada, procesamiento y salida. En 1945, John von Neumann propuso un concepto conocido como programa almacenado, en el cual los datos y los programas se almacenan en una estructura llamada memoria, separada del hardware que ejecuta las instrucciones. Este esquema permite que las computadoras sean más fáciles de reprogramar y es conocido actualmente como arquitectura de von Neumann. Sus componentes principales son la memoria principal, la unidad central de procesamiento (CPU) y los sistemas de entrada y salida.\nEl código máquina es un conjunto de instrucciones binarias interpretables por la CPU de una computadora. Un programa consiste de una secuencia de instrucciones en código máquina. Debido a que programar una computadora de esta manera es muy lento y complicado, en la década de 1950 comenzaron a crearse lenguajes de programación los cuales, en lugar de unos y ceros, consisten de instrucciones formadas por palabras, usualmente en idioma inglés. Existe una gran variedad de lenguajes de programación que han sido creados con diversos fines: científicos, comerciales, educacionales, etc.\nEl pensamiento computacional es un enfoque para la resolución de problemas basado en conceptos y métodos de las ciencias de la computación. Sus principios fundamentales son:\nScratch es un lenguaje de programación orientado a educación. Fue desarrollado en 2003 por el MIT Media Lab y es administrado por la Fundación Scratch, una organización sin fines de lucro que lo facilita de manera gratuita.",
    "crumbs": [
      "I Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción a la programación de computadoras</span>"
    ]
  },
  {
    "objectID": "01-introduccion-programacion-computadoras.html#resumen",
    "href": "01-introduccion-programacion-computadoras.html#resumen",
    "title": "1  Introducción a la programación de computadoras",
    "section": "",
    "text": "Descomposición: división de un problema en subproblemas más pequeños.\nReconocimiento de patrones: búsqueda de similitudes en los problemas.\nAbstracción: filtrado de la información que se necesita y de la que no se necesita para resolver un problema.\nAlgoritmos: descripción, paso por paso, de la solución a un problema.",
    "crumbs": [
      "I Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción a la programación de computadoras</span>"
    ]
  },
  {
    "objectID": "01-introduccion-programacion-computadoras.html#trabajo-previo",
    "href": "01-introduccion-programacion-computadoras.html#trabajo-previo",
    "title": "1  Introducción a la programación de computadoras",
    "section": "1.2 Trabajo previo",
    "text": "1.2 Trabajo previo\n\n1.2.1 Lecturas y videos\nCS50 (Director). (2024). CS50x 2024—Lecture 0—Scratch. https://www.youtube.com/watch?v=3LPJfIKxwWc\nWing, J. M. (2006). Computational thinking. Communications of the ACM, 49(3), 33-35. https://doi.org/10.1145/1118178.1118215",
    "crumbs": [
      "I Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción a la programación de computadoras</span>"
    ]
  },
  {
    "objectID": "01-introduccion-programacion-computadoras.html#computadoras-algoritmos-y-programas",
    "href": "01-introduccion-programacion-computadoras.html#computadoras-algoritmos-y-programas",
    "title": "1  Introducción a la programación de computadoras",
    "section": "1.3 Computadoras, algoritmos y programas",
    "text": "1.3 Computadoras, algoritmos y programas\n\n1.3.1 Capacidades de las computadoras\nUna computadora es una máquina que ejecuta secuencias de instrucciones. Estas secuencias se denominan programas. Las instrucciones de los programas realizan diversos tipos de operaciones entre los que pueden mencionarse:\n\nCálculos aritméticos: sumar, restar, multiplicar, dividir.\nProcesamiento de texto: buscar, reemplazar, dividir y concatenar cadenas de texto.\nOperaciones lógicas: determinar si un número es mayor que otro, si una hilera está contenida en otra hilera o si un elemento está en una lista.\nManipulación de datos: crear, leer, actualizar y eliminar datos en estructuras de datos (ej. listas, vectores, matrices) o en bases de datos.\nInteracciones con el usuario: recibir entradas del usuario (ej. del teclado o del ratón) y mostrarle información (ej. en la pantalla o en la impresora).\nManejo de archivos: leer, escribir y modificar archivos.\nComunicaciones en red: enviar y recibir datos a través de una red local o de la Internet (ej. páginas web, corres electrónicos).\n\nLa capacidad que tienen las computadoras de ser programadas, permite que su funcionamiento sea modificado sin necesidad de alterar sus componentes físicos, lo que las hace muy versátiles y aptas para ayudar a resolver una gran variedad de problemas, por lo que se dice que son de propósito general. Estas características las diferencian de otros tipos de máquinas, las cuales han sido construídas con fines específicos.\n\n\n1.3.2 Algoritmos\nPara que una computadora sea útil en la solución de un problema, es necesario expresarlo mediante un conjunto de pasos claramente definidos. A estos conjuntos de pasos se les conoce como algoritmos. Más detalladamente, un algoritmo es un conjunto de instrucciones o reglas definidas y no ambiguas, ordenadas y finitas que permite solucionar un problema. Los algoritmos son fundamentales en ciencias de la computación, ya que son la base sobre la que se construyen los programas.\nUn algoritmo puede ser tan sencillo como una receta de cocina o tan complejo como los que se utilizan en aprendizaje automático (machine learning).\nUn algoritmo debe cumplir con ciertas características básicas:\n\nRecibir entradas: datos con los que trabaja.\nGenerar salidas: resultados generados por las operaciones que ejecuta el algoritmo.\nCada paso debe ser claro: la definición de cada paso debe ser precisa y sin ambigüedades.\nDebe ser finito: debe terminar después de un número finito de pasos.\n\nHay varias formas de representar un algoritmo, entre las que están el pseudocódigo, un diagrama de flujo o simplemente una descripción escrita. A manera de ejemplo, se presenta seguidamente la descripción de un algoritmo para obtener el valor máximo de una lista:\nAlgoritmo para obtener el valor máximo de una lista\n---------------------------------------------------\n\n1. Lea la lista (del teclado, de un archivo o de alguna otra fuente).\n2. Si la lista está vacía, despliegue la hilera de texto \"Lista vacía\" \n   y concluya el algoritmo. Si no, continúe con el paso 3.\n3. Designe el primer elemento de la lista como \"máximo actual\".\n4. Recorra la lista y compare cada uno de los elementos con el máximo actual.\n   4.1. Si un elemento comparado es mayor que el máximo actual, \n        entonces desígnelo como el nuevo máximo actual.\n5. Al finalizar el recorrido de la lista, imprima el máximo actual\n   como valor máximo de la lista.\nSeguidamente, se muestra la aplicación de este algoritmo a una lista de ejemplo.\n\nLista leída: [29.6, -36.81, 31.85, 25.71, 90.2, 0.4]\nLa lista no está vacía, por lo que se continúa con el paso 3.\nSe designa al primer elemento de la lista, 29.6, como el máximo actual.\nSe recorre la lista y se compara cada uno de los elementos con el máximo actual.\n4.1. Si un elemento comparado es mayor que el máximo actual, entonces pasa a ser el nuevo máximo actual.\n\nElemento en negrita = máximo actual\nElemento en itálica = elemento que está siendo comparado\n[29.6, -36.81, 31.85, 25.71, 90.2, 0.4]\n[29.6, -36.81, 31.85, 25.71, 90.2, 0.4]\n[29.6, -36.81, 31.85, 25.71, 90.2, 0.4]\n[29.6, -36.81, 31.85, 25.71, 90.2, 0.4]\n[29.6, -36.81, 31.85, 25.71, 90.2, 0.4]\n[29.6, -36.81, 31.85, 25.71, 90.2, 0.4]\n\nAl finalizar el recorrido de la lista, se imprime el máximo actual como valor máximo de la lista: 90.2\n\nNote que el algoritmo tiene claramente definido un inicio (la lectura de la lista) y establace cual es la condición que debe cumplirse para su finalización (que termine el recorrido de la lista). Asimismo, cada uno de los pasos intermedios está especificado con claridad, incluyendo las condiciones para que se ejecuten.\nNote además que el algoritmo incluye:\n\nLectura de entradas: la lista.\n\nProcesamiento de las entradas: recorrido de la lista y comparaciones entre sus elementos.\n\nGeneración de salidas: el valor máximo de la lista.\n\n\n\n1.3.3 El modelo Entrada - Procesamiento - Salida\nEl modelo Entrada - Procesamiento - Salida (Input - Process - Output o IPO) describe la estructura básica de un algoritmo o de un programa de cómputo. Es un concepto fundamental en computación que describe el flujo de trabajo básico que emplean los sistemas para procesar información o datos. De acuerdo con este modelo, un algoritmo o programa recibe entradas (ej. números), las procesa (realiza cálculos matemáticos) y genera salidas (resultados de los cálculos).\nEl modelo Entrada - Procesamiento - Salida se esquematiza en la Figura 1.1.\n\n\n\n\n\n\nFigura 1.1: Modelo Entrada - Procesamiento - Salida\n\n\n\nA continuación se describen los componentes del modelo:\n\nEntrada (Input): consiste de datos o información que recibe el sistema. Pueden venir en diversas formas, como señales electrónicas, datos tecleados por un usuario o archivos, entre otros. La calidad y precisión de la entrada pueden afectar significativamente el resultado final del proceso.\nProcesamiento (Process): Una vez que los datos de entrada son recibidos, el sistema los procesa de acuerdo con un conjunto de instrucciones o pasos. El procesamiento puede involucrar operaciones como cálculos matemáticos, operaciones lógicas, transformaciones o cualquier otra acción necesaria para generar la salida que se requiere. En este componente es usualmente donde se realiza el “trabajo” principal del sistema.\nSalida (Output): Una vez finalizado el procesamiento, el sistema genera una salida. La salida es el resultado del proceso y puede presentarse en varias formas, como una visualización en pantalla, un archivo o un documento impreso, entre otras posibilidades. La salida puede ser el final del algoritmo o programa o puede servir como entrada para otro algoritmo o programa.\n\nPara ilustrar el modelo Entrada - Procesamiento - Salida, se muestra su aplicación al cálculo del índice de masa corporal (IMC), una razón matemática que clasifica el peso de las personas en categorías como bajo, normal y sobrepeso, con base en su masa y su estatura. El IMC necesita dos entradas: masa (en kilogramos) y estatura (en metros). El procesamiento se realiza mediante la fórmula: imc = imc = masa/estatura2.\nEntonces, un posible algoritmo para calcular el IMC de una persona es:\n\nLea la masa y la estatura de la persona.\nCalcule el imc mediante la fórmula: imc = masa/estatura2.\nImprima el imc.\n\nEjercicios\nCalcule manualmente su IMC y verifique el resultado con esta calculadora de IMC.\n\n\n1.3.4 Implementación de algoritmos en programas\nEl diseño de un algoritmo puede verse como un paso previo a la elaboración de un programa de cómputo. Un mismo algoritmo puede implementarse en diferentes lenguajes de programación. Seguidamente se presenta la implementación del algoritmo de obtención del valor máximo de una lista en los lenguajes de programación Python y R.\n\n\n\n\n\n\n# Python\n# Obtención del valor máximo de una lista\n\n# Entrada\nlista = [29.6, -36.81, 31.85, 25.71, 90.2, 0.4]\nprint(\"Lista de entrada: \", lista)\n\n# Procesamiento\nif (len(lista) == 0):\n    print(\"La lista está vacía\")\nelse:\n    max = lista[0]\n    i = 0\n    while (i &lt; len(lista)):\n        if (lista[i] &gt; max):\n            max = lista[i]\n        i = i + 1\n        \n    # Salida\n    print(\"Valor máximo de la lista:\", max) \n\n\n# R\n# Obtención del valor máximo de una lista\n\n# Entrada\nlista &lt;- c(29.6, -36.81, 31.85, 25.71, 90.2, 0.4)\ncat(\"Lista de entrada: \", lista, \"\\n\")\n\n# Procesamiento\nif (length(lista) == 0) {\n  cat(\"La lista está vacía\", \"\\n\")\n} else {\n  max &lt;- lista[1]\n  i &lt;- 1\n  while (i &lt;= length(lista)) {\n    if (lista[i] &gt; max) {\n      max &lt;- lista[i]\n    }\n    i &lt;- i + 1\n  }\n  \n  # Salida\n  cat(\"Valor máximo de la lista: \", max, \"\\n\")\n}\n\n\n\nEjercicios\n\nEjecute los programas anteriores en R y Python en los siguientes ambientes de ejecución en línea. Solamente debe copiar cada programa en el espacio destinado para ese fin y presionar el botón Run (ejecutar, correr).\n\nAmbiente de ejecución en línea para Python\nAmbiente de ejecución en línea para R\n\nCon base en la descripción del IMC brindada en la sección anterior, elabore una hoja electrónica que calcule el IMC para 10 personas. Considere como incluir los componentes de entrada, procesamiento y salida.\nCon base en el algoritmo descrito en la sección para el cálculo del IMC, elabore un programa en Python y otro programa en R que calculen el IMC de una persona.",
    "crumbs": [
      "I Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción a la programación de computadoras</span>"
    ]
  },
  {
    "objectID": "01-introduccion-programacion-computadoras.html#arquitectura-de-computadoras",
    "href": "01-introduccion-programacion-computadoras.html#arquitectura-de-computadoras",
    "title": "1  Introducción a la programación de computadoras",
    "section": "1.4 Arquitectura de computadoras",
    "text": "1.4 Arquitectura de computadoras\nEn esta sección, se explican los principales componentes de las computadoras modernas. Se realiza un recorrido por algunos de los principales antecedentes históricos de su evolución y se detallan los componentes de la arquitectura de von Neumann, el modelo de arquitectura más utilizado en la actualidad.\n\n1.4.1 Evolución histórica\n\n1.4.1.1 Calculadoras mecánicas\nDurante el siglo XVII, varios matemáticos construyeron calculadoras mecánicas capaces de realizar operaciones aritméticas.\nAlrededor de 1645, el filósofo y matemático francés Blaise Pascal (1623-1662) inventó la Pascalina, una calculadora compuesta por ruedas y engranajes que podía sumar y restar. Pascal la creó con el propósito de ayudar a su padre, quien era contador en la Hacienda francesa y necesitaba una herramienta para realizar cálculos de aritmética comercial de manera más eficiente. La Pascalina podía sumar hasta tres partes en una sola operación, llegando al valor de 999 999 como máximo.\nEn 1672, el científico alemán Gottfried Leibniz (1646 - 1716) extendió las ideas de Pascal e introdujo la Stepped Reckoner o máquina de Leibniz, un dispositivo que, además de sumar y restar, podía multiplicar, dividir y calcular raíces cuadradas. La máquina de Leibniz estaba basada en un dispositivo llamado rueda de Leibniz, un tambor con forma de cilindro, con un conjunto de dientes de longitud incremental a la que se le acopla una rueda de conteo. La Figura 1.2 muestra una réplica de la máquina de Leibniz.\n\n\n\n\n\n\nFigura 1.2: Réplica de la máquina de Leibniz. Fuente: Kolossos a través de Wikimedia Commons.\n\n\n\nEl objetivo de Leibniz era realizar cálculos de una manera “fácil, rápida y fiable”. También pretendía que los números calculados pudieran ser tan grandes como se deseara, si el tamaño de la máquina era ajustado. Sin embargo, las primeras versiones de la rueda de Leibniz no eran fiables debido a que tenían piezas mecánicas que tendían a trabarse y a fallar.\nLos derivados de las calculadoras mecánicas creadas por Pascal y Leibniz continuaron siendo producidos durante tres siglos, hasta que a principios de los años 1970 sus equivalentes electrónicos finalmente llegaron a ser fácilmente disponibles y baratos.\n\n\n1.4.1.2 La máquina analítica de Babbage\nEn la primera mitad del siglo XIX, el matemático inglés Charles Babbage (1791 - 1871) diseñó la máquina analítica, una computadora mecánica que incorporaba algunas características de las computadoras modernas. Fue inicialmente descrita en 1837, aunque Babbage continuó refinando el diseño hasta su muerte en 1871. Es considerada la primera computadora programable de la historia. La máquina analítica de Babbage se muestra en la Figura 1.3.\n\n\n\n\n\n\nFigura 1.3: Máquina analítica de Babbage. Fuente: Bruno Barral a través de Wikimedia Commons.\n\n\n\nAunque nunca fue terminada debido a limitaciones técnicas y económicas, su diseño revolucionario permitía realizar cálculos complejos y programarla para diversas tareas. Utilizaba tarjetas perforadas para la entrada de datos, disponía de una unidad aritmética para realizar operaciones matemáticas y una memoria capaz de almacenar hasta 1000 números. El lenguaje de programación que sería utilizado era similar a los actuales lenguajes ensambladores. Era posible implementar ciclos y condicionales de manera que el lenguaje propuesto habría sido Turing-completo.\nEn 1843, la matemática británica Ada Lovelace (1815 - 1852) tradujo al inglés una descripción de la máquina analítica escrita en francés un año antes por el matemático italiano Luigi Menabrea (1809 - 1896). Entre las notas que acompañan la traducción, Lovelace incluyó el detalle de los pasos mediante los cuales la máquina podría calcular los números de Bernoulli, lo que se considera por algunos el primer programa de computadoras de la historia. El diagrama correspondiente a este algoritmo/programa se muestra en la Figura 1.4.\n\n\n\n\n\n\nFigura 1.4: Diagrama de un algoritmo para el cálculo de los números de Bernoulli en la máquina analítica de Babbage. Fuente: Ada Lovelace a través de Wikimedia Commons.\n\n\n\nAhora se cree que el autor de este programa fue probablemente el mismo Charles Babbage, que ya había desarrollado trabajos similares entre seis y siete años antes de la publicación del artículo de Lovelace.\nEl aporte de Ada Lovelace fue de suma importancia para la computación, ya que fue la primera en reconocer la capacidad de las máquinas para ir más allá de los simples cálculos de números. Acertadamente, anticipó que en el futuro podrían hacer muchas otras cosas, como componer música o generar gráficos. En sus notas, Lovelace enfatizó la diferencia entre la máquina analítica y las máquinas de cálculo previas, en particular su capacidad de ser programada para resolver problemas de mayor complejidad.\n\n\n1.4.1.3 La máquina de Turing\nEn 1936, el matemático británico Allan Turing (1912 - 1954) propuso la máquina de Turing, un modelo matemático que manipula símbolos en una cinta según un conjunto de reglas. La Figura 1.5 muestra una representación artística de la máquina de Turing.\n\n\n\n\n\n\nFigura 1.5: Representación artística de la máquina de Turing. Fuente: Porao a través de Wikimedia Commons.\n\n\n\nUna máquina de Turing está compuesta por:\n\nUna cinta: actúa como memoria de la máquina. Se compone de celdas, cada una de las cuales puede contener un símbolo (ej. una letra, un número).\nUna cabeza lectora/escritora: lee y escribe símbolos en la cinta.\nUn conjunto de estados: entre los cuales la máquina puede cambiar en respuesta a lo que lee en la cinta. Hay un estado inicial desde el cual el funcionamiento de la máquina comienza, y uno o más estados de parada que indican que la máquina ha terminado su computación.\nUna tabla de acciones: indica para combinación de estado actual y símbolo leído en la cinta, qué acción debe realizar la máquina. Estas acciones incluyen leer o escribir un símbolo en la cinta, mover la cabeza lectora/escritora a la izquierda o a la derecha sobre la cinta y cambiar a un nuevo estado.\n\nCon este esquema, una máquina de Turing puede ejecutar cualquier algoritmo. El modelo de Turing demostró que una máquina simple podía resolver cualquier problema computable, si cuenta con el tiempo y los recursos necesarios. Si un sistema (ej. una computadora, un lenguaje de programación) puede utilizarse para resolver cualquier problema de cómputo, se dice que es Turing-completo. No todos los sistemas o lenguajes son Turing-completos, ya que algunos están diseñados para propósitos específicos y pueden tener restricciones que limitan su capacidad de cálculo.\nAllan Turing es considerado uno de los padres de la computación moderna. Sus contribuciones fueron fundamentales en el desarrollo de la teoría de la computación y la inteligencia artificial. En esta última área, Turing propuso un experimento para determinar si una máquina puede exhibir inteligencia equivalente a la de un ser humano. Este experimento, conocido como Prueba de Turing, sigue siendo una referencia en el debate sobre la inteligencia artificial.\n\n\n1.4.1.4 Primeras computadoras electrónicas\nCon base en las ideas de Turing, las computadoras de tipo Bombe y Colossus fueron construídas durante la II Guerra Mundial (1939 - 1945) en el Reino Unido para descifrar mensajes codificados. A pesar de que se consideran de las primeras computadoras digitales electrónicas programables, su programación se realizaba a través de componentes de hardware, como interruptores y enchufes, y no con un programa almacenado en la memoria. La Figura 1.6 muestra una computadora Colossus.\n\n\n\n\n\n\nFigura 1.6: Computadora Colossus operada por integrantes del Women’s Royal Naval Service (WRNS). Fuente: Fotografía de autor desconicido compartida a través de Wikimedia Commons.\n\n\n\nTambién durante la II Guerra Mundial, el ejército de Estados Unidos de América construyó ENIAC (Electronic Numerical Integrator and Computer) para calcular tablas de tiro de artillería. Es considerada por algunos como la primera computadora programable digital de propósito general. Era capaz de seguir el modelo de la máquina de Turing, por lo que era Turing-completa. La Figura 1.7 presenta una imagen de ENIAC.\n\n\n\n\n\n\nFigura 1.7: Computadora ENIAC en Filadelfia, EE UU. Fuente: Fotografía del Ejército de los Estados Unidos de América compartida a través de Wikimedia Commons.\n\n\n\n\n\n\n1.4.2 La arquitectura de von Neumann\nEn 1945, el matemático húngaro - estadounidense John von Neumann (1903 - 1957) propuso un concepto conocido como programa almacenado según el cual los datos y los programas de una computadora se almacenan en una estructura llamada memoria, separada de los componentes que ejecutan las instrucciones. Este modelo permite que las computadoras sean más fáciles de reprogramar y es conocido actualmente como arquitectura de von Neumann. Su esquema se muestra en la Figura 1.8.\n\n\n\n\n\n\nFigura 1.8: Arquitectura de von Neumann. Imagen de David Strigoi compartida a través de Wikimedia Commons.\n\n\n\nLos principales componentes de esta arquitectura son:\n\nMemoria principal. Almacena las instrucciones de los programas y los datos que utilizan estos programas. Es común denominarla como Random Access Memory (Memoria de Acceso Aleatorio) o RAM, ya que toma el mismo tiempo acceder a cualquier posición de la memoria. Cada posición de memoria tiene una dirección a la que se hace referencia cuando se desea leer o escribir.\nUnidad central de procesamiento. Llamada en inglés Central Processing Unit (CPU), se encarga de ejecutar las instrucciones de los programas. Contiene memorias temporales de alta velocidad y poca capacidad llamadas registros para almacenar los operandos y el resultado de las instrucciones. Está compuesta por dos partes principales:\n\nUnidad de control. Determina cuál es la siguiente instrucción a ejecutar.\nUnidad de aritmética y lógica. Llamada en inglés Arithmetic and Logic Unit (ALU), ejecuta las operaciones aritméticas y lógicas.\n\nSistemas de entrada y salida. Permiten que la computadora interactúe con el usuario y, en general, con el mundo exterior. Algunos ejemplos son el teclado y el ratón, como sistemas de entrada, y la pantalla y la impresora, como sistemas de salida.\n\n\n\n1.4.3 Sistemas binarios\nLas computadoras modernas están construídas con base en circuitos integrados, también llamados chips o microchips, como el que se muestra en la Figura 1.9.\n\n\n\n\n\n\nFigura 1.9: Procesador Intel. Imagen de Slejven Djurakovic compartida a través de Unsplash.\n\n\n\nLos circuitos integrados procesan información digital (que usa valores discretos), la cual generalmente es binaria, lo que significa que puede tener dos valores. Para representar estos dos valores internamente, las computadoras emplean dos niveles de tensión eléctrica: bajo (o ausencia de tensión) y alto (o presencia de tensión eléctrica). Estos estados se representan respectivamente con 0 y 1 (o viceversa). Este es un sistema binario y cada dígito binario se denomina bit (binary digit). Los bits se agrupan en grupos de ocho llamados bytes) para representar elementos de información más complejos, como números más grandes o carácteres de texto. Por ejemplo:\n\nEl número decimal 14 se representa en binario como 1110:\n1110 = 2^3*1 + 2^2*1 + 2^1*1 + 2^0*0 = 8 + 4 + 2 + 0 = 14\nLa palabra bit se representa en código ASCII como:\n01100010 01101001 01110100 = bit\n\nDe manera similar, se pueden representar otras clases de información, como imágenes, sonidos o videos, mediante secuencias de dígitos binarios.\nEl uso de dos estados (en lugar de diez, doce u otra cantidad) facilita la aplicación de la teoría de la información, el estudio matemático de la cuantificación, almacenamiento y comunicación de la información, en el cual los bits son la unidad fundamental. La teoría de la información fue proṕuesta por el matemático estadounidense Claude Shannon (1916 - 2001) en la década de 1940.\nEl álgebra booleana, un pilar fundamental en el campo del análisis y diseño de sistemas digitales, así como en la programación de computadoras, también utiliza dos posibles valores: verdadero (1) y falso (0). Fue introducida en 1847 por el matemático británico George Boole (1815 - 1864). El álgebra booleana utiliza operaciones lógicas como AND (y), OR (o) y NOT (no) para combinar y transformar valores booleanos (verdaderos y falsos).\nPor otra parte, es más fácil diseñar y fabricar dispositivos electrónicos que solo necesitan reconocer dos estados. Por esta razón, los circuitos que manejan señales binarias pueden ser más simples, más confiables y menos costosos que aquellos que tendrían que manejar múltiples estados.\n\n\n1.4.4 Código máquina\nEl código máquina es un conjunto de instrucciones binarias (compuestas por unos y ceros) interpretables por un CPU. Un programa consiste de una secuencia de instrucciones en código máquina. Este es el único lenguaje que “entienden” directamente las computadoras.\nEl código máquina, siendo el más bajo nivel de lenguaje de programación y directamente entendible por el hardware del procesador, incluye varios tipos de instrucciones esenciales para la operación de una computadora. Estas instrucciones varían según la arquitectura del procesador (ej. x86, ARM, MIPS), pero generalmente se pueden agrupar en categorías como, por ejemplo:\n\nInstrucciones de aritmética y lógica. Realizan operaciones matemáticas básicas como suma, resta, multiplicación y división, así como operaciones lógicas como AND, OR y NOT.\nInstrucciones de manipulación de datos. Permiten el movimiento de datos dentro de la CPU o entre la CPU y la memoria. Ejemplos incluyen la carga (load) de datos desde la memoria al registro, almacenamiento (store) de datos del registro a la memoria, y transferencias de datos entre registros.\nInstrucciones de entrada/salida. Facilitan la comunicación entre la CPU y los dispositivos de entrada/salida, como discos duros, teclados, pantallas y otros.\nInstrucciones de comparación. Comparan valores y, a menudo, se usan junto con las instrucciones de control de flujo (ej. condicionales, ciclos) para tomar decisiones basadas en estas comparaciones.\nInstrucciones de operación de punto flotante. Específicas para el procesamiento de números de punto flotante, permiten realizar operaciones aritméticas sobre estos números, que son fundamentales para el cálculo científico y la ingeniería.\n\nCada instrucción en código máquina se representa como una secuencia de bits, y el conjunto específico de instrucciones que un procesador puede ejecutar se conoce como su conjunto de instrucciones o Instruction Set Architecture (ISA).\nLa Figura 1.10 muestra una instrucción en código máquina que suma los contenidos de los registros 1 y 2 y almacena el resultado en el registro 6 de un CPU:\n\n\n\n\n\n\nFigura 1.10: Instrucción en código máquina. Imagen de Wikipedia.\n\n\n\nLa Figura 1.11 muestra el programa Hola mundo (Hello World) en código máquina. Este programa simplemente imprime la hilera de texto “Hola mundo”, usualmente en la pantalla, y suele ser usado como introducción al estudio de un lenguaje de programación, siendo un primer ejercicio típico.\n\n\n\n\n\n\nFigura 1.11: Programa Hola mundo en código máquina. Imagen de CS50x 2024 - Lecture 0 - Scratch.",
    "crumbs": [
      "I Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción a la programación de computadoras</span>"
    ]
  },
  {
    "objectID": "01-introduccion-programacion-computadoras.html#lenguajes-de-programación",
    "href": "01-introduccion-programacion-computadoras.html#lenguajes-de-programación",
    "title": "1  Introducción a la programación de computadoras",
    "section": "1.5 Lenguajes de programación",
    "text": "1.5 Lenguajes de programación\nDebido a que programar una computadora en código máquina es muy lento y complicado, en la década de 1950 comenzaron a crearse lenguajes de programación que, en lugar de unos y ceros, consisten de instrucciones formadas por palabras, usualmente en idioma inglés. A manera de ejemplo, seguidamente se muestra el programa “Hola mundo” en varios lenguajes de programación:\nLenguaje C\n/* Hola mundo en lenguaje C */\n\n#include &lt;stdio.h&gt;\n\nmain()\n{\n    printf(\"Hola mundo\\n\");\n}\nLenguaje Python\n# Hola mundo en lenguaje Python\n\nprint(\"Hola mundo\")\nLenguaje R\n# Hola mundo en lenguaje R\n\ncat(\"Hola mundo\\n\")\nEl sitio web The Hello World Collection presenta el programa “Hola mundo” en más de 600 lenguajes de programación. Existe una gran variedad de lenguajes de programación que han sido creados con diversos fines: científicos, comerciales, educacionales, etc.",
    "crumbs": [
      "I Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción a la programación de computadoras</span>"
    ]
  },
  {
    "objectID": "01-introduccion-programacion-computadoras.html#pensamiento-computacional",
    "href": "01-introduccion-programacion-computadoras.html#pensamiento-computacional",
    "title": "1  Introducción a la programación de computadoras",
    "section": "1.6 Pensamiento computacional",
    "text": "1.6 Pensamiento computacional\nComo se ha mencionado, utilizamos computadoras porque nos ayudan a resolver problemas. La forma de solucionar un problema debe expresarse de manera que pueda ser implementada en una computadora: mediante programación (vea la Figura 1.12).\n\n\n\n\n\n\nFigura 1.12: Resolución de problemas mediante computadoras.\n\n\n\nEl pensamiento computacional es un enfoque para la resolución de problemas basado en conceptos y métodos de las ciencias de la computación. Puede ser aplicado en otras áreas. Se considera una de las destrezas fundamentales del siglo XXI.\nEl pensamiento computacional tiene cuatro principios fundamentales:\n\nDescomposición: división de un problema en subproblemas más pequeños.\nReconocimiento de patrones: búsqueda de similitudes de un problema a resolver, con problemas ya resueltos.\nAbstracción: filtrado de la información que se necesita y de la que no se necesita para resolver un problema.\nAlgoritmos: descripción, paso por paso, de la solución a un problema.",
    "crumbs": [
      "I Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción a la programación de computadoras</span>"
    ]
  },
  {
    "objectID": "01-introduccion-programacion-computadoras.html#el-lenguaje-de-programación-scratch",
    "href": "01-introduccion-programacion-computadoras.html#el-lenguaje-de-programación-scratch",
    "title": "1  Introducción a la programación de computadoras",
    "section": "1.7 El lenguaje de programación Scratch",
    "text": "1.7 El lenguaje de programación Scratch\nScratch es un lenguaje de programación orientado a educación. Su nombre proviene de la palabra en inglés scratching. Fue desarrollado en 2003 por el MIT Media Lab y es administrado por la Fundación Scratch, una organización sin fines de lucro que lo facilita de manera gratuita. Es software libre que se comparte mediante una licencia GPLv2. Se basa en bloques gráficos que se arrastran y sueltan para crear proyectos interactivos, como juegos, animaciones e historias.\n\n1.7.1 Ambiente de desarrollo\nScratch ofrece un ambiente de desarrollo en línea en la dirección https://scratch.mit.edu/, el cual se muestra en la Figura 1.13.\n\n\n\n\n\n\nFigura 1.13: Ambiente de desarrollo de Scratch.\n\n\n\nEl ambiente de desarrollo está compuesto por varias zonas o áreas. Seguidamente se describen algunas de las principales:\n\nUn área de bloques, a la izquierda de la pantalla, los cuales ejecutan tareas como mover, girar, ir a, etc. Estos bloques son las instrucciones o comandos de Scratch. Se agrupan en secciones: Movimiento, Apariencia, Sonido, etc.\nUn área en el centro de la pantalla al que pueden arrastrarse los bloques con el ratón para unirse y acoplarse.\nUn área en la parte superior derecha de la pantalla, llamada escenario, en la que se despliega el resultado de las tareas ejecutadas por los bloques.\nUn área en la parte inferior derecha de la pantalla en la que se seleccionan y configuran los sprites. Estos son los objetos o personajes que aparecen en el escenario y que responden a instrucciones especificadas mediante bloques de código.\nUn botón ubicado en la esquina inferior izquierda de la pantalla llamado Agregar Extensión. En el contexto de Scratch, una extensión es un grupo de tareas adicional a los bloques que se despliegan por defecto. Las extensiones pueden ser desarrolladas por programadores diferentes a los creadores de Scratch.\n\nNota: si lo desea, puede cambiar el idioma a español, u otro de su preferencia, con la opción de menú Settings - Language.\n\n\n1.7.2 Ejercicios\nA continuación, se proponen diferentes ejercicios de programación para ilustrar los principios de pensamiento computacional y familiarizarse con el ambiente de desarrollo de Scratch.\n\n1.7.2.1 Programa “Hola mundo”\nPara desplegar en la pantalla la hilera de texto “Hola mundo”, se sugiere seguir los siguientes pasos:\n\nIngrese al sitio web de Scratch y presione el botón Start Creating o Crear para iniciar un proyecto (para este curso, no es necesario crear un usuario en el sitio). Se desplegará el ambiente de programación de Scratch.\nCon el bloque decir de la sección Apariencia, despliegue la frase “Hola Mundo”.\nUtilice el evento al presionar de la sección Eventos para poder ejecutar el programa al presionar la bandera de salida.\n\n\n\n\n\n\n\n\n\n\n\n\n(a) Código fuente\n\n\n\n\n\n\n\n\n\n\n\n(b) Salida\n\n\n\n\n\n\n\nFigura 1.14: Código fuente y salida del programa “Hola mundo”\n\n\n\n\nUtilice los bloques de la extensión Texto a voz para que el gato pronuncie la frase “Hola mundo”.\nCon la opción de menú Archivo - Guardar en tu computador, guarde el programa en un archivo. Se recomienda cambiar el nombre del archivo por uno más significativo.\nSalga del sitio web de Scratch, vuelva a entrar y cargue el programa que guardó con la opción de menú Archivo - Subir desde tu computador.\n\n\n\n1.7.2.2 Dibujar un paisaje\n\nProblema a resolver\nDibujar un paisaje como el que se muestra en la siguiente figura.\n Agregue la extensión Lápiz y pruebe bloques como bajar lápiz, subir lápiz, borrar todo, mover, girar, ir a, apuntar en dirección y cualquier otro que le sea útil. Dibuje un par de figuras para familiarizarse con esos comandos.\n\n\nAplicación de principios del pensamiento computacional\nLos principios del pensamiento computacional pueden aplicarse de la siguiente manera en la resolución del problema:\nDescomposición\nSe identifican los siguientes subproblemas:\n\nDibujo de una casa.\n\nDibujo de la base.\nDibujo del techo.\n\nDibujo de un edificio (casa de dos pisos).\n\nDibujo de una base.\nDibujo de otra base.\nDibujo del techo.\n\n\nReconocimiento de patrones\n\nDibujar una base es lo mismo que dibujar un cuadrado (cuatro lados iguales y cuatro ángulos iguales de 90°).\nDibujar un techa es lo mismo que dibujar un triángulo equilátero (tres lados iguales y tres ángulos iguales de 60°).\n\nAbstracción\n\nInformación relevante:\n\nValor de x.\nValor de y.\nLongitud del lado de los cuadrados y triángulos.\n\nInformación no relevante:\n\nColor de las figuras.\nAncho de las líneas.\nApariencia del escenario.\n\n\nAlgoritmo\nEl siguiente algoritmo describe paso por paso el procesamiento para llegar a una solución.\n\nBorrar la pantalla.\nDibujar una casa de lado 50 en la posición (-160, 10).\nDibujar una casa de lado 60 en la posición (-85, -140).\nDibujar una casa de lado 75 en la posición (145, -60).\nDibujar un edificio de lado 75 en la posición (10, -40).\n\nLos dibujos de las casas y de los edificios pueden basarse en el siguiente pseudocódigo:\ndibujar_casa (x, y, lado)\n  dibujar_base (x, y, lado)\n  dibujar_techo (x, y + lado, lado)\n\ndibujar_edificio (x, y, lado)\n  dibujar_base (x, y, lado)\n  dibujar_base (x, y + lado, lado)\n  dibujar_techo (x, y + lado*2, lado)\n  \ndibujar_base (x, y, lado)\n  subir_lapiz\n  ir_a (x, y)\n  apuntar_en_direccion (90)\n  bajar_lapiz\n  repetir 4 veces\n    esperar_segundos (0.5)\n    mover (lado)\n    girar_derecha (90)\n    \ndibujar_techo (x, y, lado)\n  subir_lapiz\n  ir_a (x, y)\n  bajar_lapiz\n  apuntar_en_direccion (90)\n  repetir 3 veces\n    esperar_segundos (0.5)\n    mover (lado)\n    girar_izquierda (120)\n\n\nPosible solución\nPuede encontrar una posible solución al problema en https://github.com/gf0604-procesamientodatosgeograficos/2025-i/blob/main/scratch/paisaje.sb3.\n\n\n\n1.7.2.3 Creación de un juego\n\nProblema a resolver\nCrear un juego sencillo en el que un personaje (por ejemplo, el gato de Scratch) deba tocar objetos (por ejemplo, manzanas) que aparecen aleatoriamente en la pantalla. Al tocar una manzana, el jugador gana un punto, la manzana se mueve a una nueva posición y el jugador continúa jugando hasta llegar a cierta puntuación (ej. 5 puntos).\n\n\n\n\n\n\nFigura 1.15: Juego.\n\n\n\n\n\nAplicación de principios del pensamiento computacional\nLos principios del pensamiento computacional pueden aplicarse de la siguiente manera en la resolución del problema:\nDescomposición\nSe identifican los siguientes subproblemas:\n\nInicio del juego: Colocar el gato y la manzana en posiciones apropiadas e inicializar la puntuación.\nMovimiento del gato: Desplazar el gato con las flechas de dirección del teclado (arriba, abajo, izquierda, derecha).\nDetección de colisiones: Detectar cuando el gato toca la manzana.\nReubicación de la manzana: Mover la manzana a una posición aleatoria en la pantalla cada vez que el gato la toque.\nSistema de puntuación: Iniciar el puntaje en 0 y sumar 1 cada vez que el gato toque la manzana.\nFin del juego: Terminar el juego al alcanzar la puntuación requerida.\n\nReconocimiento de patrones\n\nEl uso de las flechas de dirección del teclado es un patrón común para mover algo en la pantalla de una computadora.\nEl sistema de puntuación acostumbra implementarse como un valor que aumenta cada vez que se cumple una condición.\n\nAbstracción\n\nInformación relevante:\n\nLa posición del gato.\nLa posición de la manzana.\nPuntuación.\n\nInformación no relevante:\n\nApareciencia (color, tamaño, etc.) del gato y de la manzana.\nApariencia del escenario.\n\n\nAlgoritmo\nEl siguiente algoritmo describe paso por paso el procesamiento para llegar a una solución.\n\nIniciar el juego.\n\nColocar el gato en el centro del escenario (x = 0, y = 0).\nColocar la manzana en una posición aleatoria.\nInicializar la variable Puntos en 0.\n\nMover el gato con las flechas de dirección del teclado.\n\nAl presionar flecha arriba, aumentar y en 10 (o la cantidad deseada).\nAl presionar flecha abajo, disminuir y en 10.\nAl presionar flecha derecha, aumentar x en 10.\nAl presionar flecha izquierda, disminuir y en 10.\n\nDetectar colisión.\n\nSi el gato toca la manzana, entonces:\n\nAumentar Puntos en 1.\nColocar la manzana en una posición aleatoria.\n\n\nFinalizar el juego.\n\nSi la variable Puntos llega a 10 (u otra cantidad estipulada), se muestra un mensaje y se finaliza el juego.\n\n\n\n\nPosible solución\nPuede encontrar una posible solución al problema en https://github.com/gf0604-procesamientodatosgeograficos/2025-i/blob/main/scratch/juego-gato-manzana.sb3.",
    "crumbs": [
      "I Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción a la programación de computadoras</span>"
    ]
  },
  {
    "objectID": "02-introduccion-ciencia-datos.html",
    "href": "02-introduccion-ciencia-datos.html",
    "title": "2  Introducción a la ciencia de datos",
    "section": "",
    "text": "2.1 Resumen\nEn este capítulo se definen algunos conceptos fundamentales de estadística, como observaciones y variables. También se introduce el área de conocimiento denominada ciencia de datos.\nUna investigación estadística se basa en datos. Los datos acostumbran representarse en tablas, en las cuales cada fila es una observación y cada columna es una variable. Una observación corresponde a un elemento de datos que ha sido estudiado y cada variable a una característica de ese elemento de datos. Las variables pueden ser numéricas o categóricas. Las numéricas se subdividen en discretas y continuas y las categóricas en nominales y ordinales.\nLa ciencia de datos es una disciplina que permite convertir datos “crudos” en comprensión y conocimiento. Incluye los procesos importar, ordenar, transformar, visualizar, modelar y comunicar.",
    "crumbs": [
      "I Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introducción a la ciencia de datos</span>"
    ]
  },
  {
    "objectID": "02-introduccion-ciencia-datos.html#trabajo-previo",
    "href": "02-introduccion-ciencia-datos.html#trabajo-previo",
    "title": "2  Introducción a la ciencia de datos",
    "section": "2.2 Trabajo previo",
    "text": "2.2 Trabajo previo\n\n2.2.1 Lecturas\nÇetinkaya-Rundel, Mine, & Hardin, Johanna (2021). Introduction to Modern Statistics (1st ed.). OpenIntro, Inc. https://openintro-ims.netlify.app/ (capítulo 1)\nWickham, Hadley; Çetinkaya-Rundel, Mirne; & Grolemund, Garret (2023). R for Data Science: Import, Tidy, Transform, Visualize, and Model Data (2nd ed.). O’Reilly Media. https://r4ds.hadley.nz/ (capítulo introductorio)",
    "crumbs": [
      "I Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introducción a la ciencia de datos</span>"
    ]
  },
  {
    "objectID": "02-introduccion-ciencia-datos.html#datos",
    "href": "02-introduccion-ciencia-datos.html#datos",
    "title": "2  Introducción a la ciencia de datos",
    "section": "2.3 Datos",
    "text": "2.3 Datos\nLos científicos tratan de responder preguntas mediante métodos rigurosos y observaciones cuidadosas. Estas observaciones, recopiladas de notas de campo, encuestas y experimentos, entre otras fuentes, forman la columna vertebral de una investigación estadística y se denominan datos. La presentación y descripción efectivas de los datos constituyen el primer paso en un análisis (Çetinkaya-Rundel & Hardin, 2021). Esta sección introduce una estructura para organizar los datos, así como alguna terminología que se utilizará a lo largo de este curso.\n\n2.3.1 Observaciones y variables\nLa siguiente tabla contiene 10 filas de un conjunto de datos. Cada fila corresponde a una persona y cada columna a una característica de esa persona. En términos estadísticos, cada fila es una observación y cada columna es una variable.\n\n\nConjunto de datos de personas.\n\n\n\n\nid\n\n\nprovincia\n\n\nequipo\n\n\nmasa\n\n\nestatura\n\n\nsexo\n\n\ncantidad_hermanos\n\n\nnivel_guitarra\n\n\n\n\n\n\n1\n\n\nLimón\n\n\nSaprissa\n\n\n51.0\n\n\n1.51\n\n\nmujer\n\n\n0\n\n\nnulo\n\n\n\n\n2\n\n\nHeredia\n\n\nHerediano\n\n\n98.5\n\n\n1.87\n\n\nhombre\n\n\n1\n\n\nalto\n\n\n\n\n3\n\n\nGuanacaste\n\n\nLiberia\n\n\n91.6\n\n\n1.65\n\n\nmujer\n\n\n4\n\n\nbajo\n\n\n\n\n4\n\n\nLimón\n\n\nLiberia\n\n\n60.6\n\n\n1.68\n\n\nmujer\n\n\n1\n\n\nalto\n\n\n\n\n5\n\n\nCartago\n\n\nCartaginés\n\n\n59.1\n\n\n1.73\n\n\nmujer\n\n\n3\n\n\nbajo\n\n\n\n\n6\n\n\notra\n\n\nSan Carlos\n\n\n59.2\n\n\n1.89\n\n\nhombre\n\n\n3\n\n\nbajo\n\n\n\n\n7\n\n\nGuanacaste\n\n\nCartaginés\n\n\n65.2\n\n\n1.70\n\n\nmujer\n\n\n3\n\n\nalto\n\n\n\n\n8\n\n\nGuanacaste\n\n\nSporting\n\n\n76.2\n\n\n1.76\n\n\nhombre\n\n\n3\n\n\nexperto\n\n\n\n\n9\n\n\nLimón\n\n\nAlajuelense\n\n\n71.6\n\n\n1.80\n\n\nhombre\n\n\n4\n\n\nbajo\n\n\n\n\n10\n\n\nAlajuela\n\n\nAlajuelense\n\n\n64.6\n\n\n1.52\n\n\nhombre\n\n\n2\n\n\nbajo\n\n\n\n\n\n\n2.3.2 Tipos de variables\nLos datos de la tabla 2.1. son de varios tipos, cuya jerarquía se muestra en la Figura 2.1.\n\n\n\n\n\n\nflowchart TB\n    A[\"Todas las variables\"] --&gt; B[\"Numéricas\"]\n    A --&gt; C[\"Categóricas\"]\n    B --&gt; D[\"Discretas\"]\n    B --&gt; E[\"Continuas\"]\n    C --&gt; F[\"Ordinales\"]\n    C --&gt; G[\"Nominales\"]\n\n\n\n\nFigura 2.1: Tipos de variables estadísticas.\n\n\n\n\n\n\n2.3.2.1 Numéricas\nCorresponden a números. Se les pueden aplicar operaciones como suma, resta, multiplicación, división y otras similares.\n\n2.3.2.1.1 Discretas\nToman valores específicos que se pueden contar. La variable cantidad_hermanos es discreta. Existe una separación clara entre sus posibles valores. Por ejemplo, es posible tener 1, 2 o 3 hermanos, pero no es posible tener 2.5 hermanos.\n\n\n2.3.2.1.2 Continuas\nPueden tomar cualquier valor dentro de un intervalo o rango continuo. Estas variables se caracterizan por su capacidad para representar medidas precisas y pueden asumir un número infinito de valores, incluso dentro de un rango limitado (ej. entre 0 y 1). Las variables masa y estatura son continuas.\n\n\n\n2.3.2.2 Categóricas\nLas variables categóricas (también llamadas cualitativas), son aquellas que describen una característica o cualidad de una observación y clasifican las observaciones en grupos o categorías. A diferencia de las variables numéricas, que expresan cantidades numéricas, las variables categóricas expresan atributos no numéricos.\n\n2.3.2.2.1 Nominales\nNo existe un orden inherente o jerarquía entre las categorías. Las variables provincia, equipo y sexo son nominales.\n\n\n2.3.2.2.2 Ordinales\nHay un orden o jerarquía clara entre las categorías. La variable nivel_guitarra es categórica.\nEjercicio\nSi se agregaran las siguientes variables al conjunto de datos de personas mostrado anteriormente, ¿cuál sería su tipo (discreta, continua, ordinal, nominal)?:\n\nCédula de identidad.\nNúmero de teléfono.\nFecha de nacimiento.\nUbicación de la residencia.",
    "crumbs": [
      "I Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introducción a la ciencia de datos</span>"
    ]
  },
  {
    "objectID": "02-introduccion-ciencia-datos.html#ciencia-de-datos",
    "href": "02-introduccion-ciencia-datos.html#ciencia-de-datos",
    "title": "2  Introducción a la ciencia de datos",
    "section": "2.4 Ciencia de datos",
    "text": "2.4 Ciencia de datos\nLa ciencia de datos es una disciplina que permite convertir datos “crudos” en comprensión y conocimiento (Wickham, Çetinkaya-Rundel, & Grolemund, 2023). Utiliza estadística y ciencias de la computación, entre otras disciplinas.\n\n2.4.1 Procesos\nLa Figura 2.2 ilustra el modelo de un proyecto típico de ciencia de datos, el cual incluye los procesos de importar, ordenar, transformar, visualizar, modelar y comunicar. Todos se articulan mediante programación de computadoras.\n\n\n\n\n\n\nFigura 2.2: Modelo de ciencia de datos. Fuente: R for Data Science.\n\n\n\n\nImportar los datos típicamente implica leerlos de un archivo, una base de datos o una interfaz de programación de aplicaciones (API) y cargarlos en un data frame.\nOrdenar u organizar (tidy) los datos significa colocarlos en estructuras rectangulares de filas y columnas, similares a tablas, de manera que cada fila sea una observación y cada columna una variable.\nTransformar los datos implica la generación de algún subconjunto de filas y columnas, la creación de nuevas variables o el cálculo de estadísticas (ej. conteos, promedios, mínimos, máximos).\nVisualizar los datos (en tablas, gráficos, mapas, etc.) permite encontrar patrones inesperados o formular nuevas preguntas.\nModelar es crear una representación abstracta y estructurada de los datos, con el fin de facilitar su análisis y realizar predicciones.\nComunicar es el último paso y es una actividad crítica de cualquier proyecto de análisis de datos o de ciencia en general.\n\n\n\n2.4.2 Ejemplo\nSe ejemplifica el proceso de ciencia de datos mediante el conjunto de datos NHANES (National Health and Nutrition Examination Survey, Encuesta Nacional de Salud y Nutrición), recopilado por el US National Center for Health Statistics (NHCS, Centro Nacional de Estadísticas de Salud de Estados Unidos), como parte de un programa de estudios diseñado para evaluar el estado de salud y nutrición de adultos y niños en los Estados Unidos. El programa NHANES selecciona muestras representativas de la población estadounidense y recopila información a través de cuestionarios, exámenes médicos y pruebas de laboratorio.\nEl conjunto de datos consta de 20293 observaciones (personas) y 78 variables de diferentes clases: antropométricas (ej. peso, altura, IMC), demográficas (ej. edad, sexo, nivel educativo, estado civil), de salud (ej. tensión arterial, estado de salud general, hábitos de consumo de tabaco) y socioeconómicas (ej. ingresos, número de habitaciones en la vivienda).\nA continuación, se muestra como los procesos de ciencia de datos, aplicados en el conjunto de datos NHANES, pueden implementarse en el lenguaje de programación R.\n\n2.4.2.1 Importar\nEl conjunto de datos se importa desde un archivo de valores separados por comas (CSV) ubicado en https://raw.githubusercontent.com/gf0604-procesamientodatosgeograficos/2025-i/refs/heads/main/datos/nchs/nhanes.csv.\n\n\nCódigo\n# Importar los datos desde un archivo CSV\nnhanes &lt;- read.csv(\n  \"https://raw.githubusercontent.com/gf0604-procesamientodatosgeograficos/2025-i/refs/heads/main/datos/nchs/nhanes.csv\"\n)\n\n# Desplegar el conjunto de datos\ndatatable(\n  nhanes,\n  caption = \"Conjunto de datos NHANES completo\",\n  rownames = FALSE,\n  options = list(\n    pageLength = 5,\n    language = list(url = '//cdn.datatables.net/plug-ins/1.10.11/i18n/Spanish.json')\n  )    \n)\n\n\n\n\n\n\nEjercicio\nDescargue el archivo CSV del conjunto de datos NHANES de https://raw.githubusercontent.com/gf0604-procesamientodatosgeograficos/2025-i/refs/heads/main/datos/nchs/nhanes.csv y examínelo con un programa de hoja de cálculo (ej. Excel, Calc). Observe las diferentes variables y sus tipos de datos.\n\n\n2.4.2.2 Ordenar (tidy)\nEn este caso, los datos están bien organizados en una estructura rectangular de filas y columnas, en la que cada fila es una observación y cada columna una variable, por lo que no es necesaria una reorganización profunda de los datos. Sin embargo, para facilitar el procesamiento, se conservan solo las columnas que son de interés y se elimina el resto.\n\n\nCódigo\n# Seleccionar columnas de interés\nnhanes &lt;- \n  nhanes[, c(\"ID\", \"Gender\", \"Age\", \"Race3\", \"Weight\", \"Height\", \"Depressed\")]\n\n# Desplegar el conjunto de datos\ndatatable(\n  nhanes,\n  caption = \"Conjunto de datos NHANES con columnas seleccionadas.\",\n  rownames = FALSE,\n  options = list(\n    pageLength = 5,\n    language = list(url = '//cdn.datatables.net/plug-ins/1.10.11/i18n/Spanish.json')\n  )    \n)\n\n\n\n\n\n\n\n\n2.4.2.3 Transformar\nEl proceso de transformación se ilustra mediante dos ejemplos.\n\n2.4.2.3.1 Promedio de estatura de personas adultas por sexo\nPara comparar las estaturas de hombres y mujeres adultos, el conjunto de datos se transforma con dos operaciones:\n\nSe filtra por edad (Age &gt;= 18).\nSe agrupa por sexo y para cada valor (\"female\",\"male\") se calcula el promedio de estatura.\n\nAdemás, la estatura (expresada en cm) se redondea a dos posiciones decimales para facilitar la lectura.\n\n\nCódigo\n# Filtrar adultos\nnhanes_adultos &lt;- subset(nhanes, Age &gt;= 18)\n\n# Calcular el promedio de estatura por sexo\nnhanes_promedio_estatura_x_sexo_adultos &lt;- aggregate(\n  data = nhanes_adultos, \n  Height ~ Gender, \n  FUN = mean, \n  na.rm = TRUE\n)\n\n# Ordenar descendentemente por estatura\nnhanes_promedio_estatura_x_sexo_adultos &lt;- \n  nhanes_promedio_estatura_x_sexo_adultos[order(-nhanes_promedio_estatura_x_sexo_adultos$Height), ]\n\n# Redondear la estatura a 2 decimales\nnhanes_promedio_estatura_x_sexo_adultos$Height &lt;- round(\n  nhanes_promedio_estatura_x_sexo_adultos$Height, \n  2\n)\n\n# Desplegar el conjunto de datos\ndatatable(\n  nhanes_promedio_estatura_x_sexo_adultos,\n  caption = \"Promedio de estatura (cm) por sexo.\",\n  rownames = FALSE,\n  options = list(\n    paging = FALSE,\n    searching = FALSE,\n    info = FALSE,\n    language = list(url = '//cdn.datatables.net/plug-ins/1.10.11/i18n/Spanish.json')\n  )    \n)\n\n\n\n\n\n\n\n\n2.4.2.3.2 Promedio de peso de personas adultas por grupo étnico\nEl conjunto de datos se transforma con tres operaciones:\n\nSe filtra por edad (Age &gt;= 18).\nSe agrupa por grupo étnico y para cada valor (\"Black\", \"Hispanic\", \"Asian\", etc.) se calcula el promedio de peso.\nSe ordena descendentemente por peso.\n\nAdemás, el peso (expresado en kg) se redondea a dos posiciones decimales para facilitar la lectura.\n\n\nCódigo\n# Filtrar adultos\nnhanes_adultos &lt;- subset(nhanes, Age &gt;= 18)\n\n# Calcular el promedio de peso por grupo étnico\nnhanes_promedio_peso_x_etnia_adultos &lt;- aggregate(\n  data = nhanes_adultos, \n  Weight ~ Race3, \n  FUN = mean, \n  na.rm = TRUE\n)\n\n# Ordenar descendentemente por peso\nnhanes_promedio_peso_x_etnia_adultos &lt;- \n  nhanes_promedio_peso_x_etnia_adultos[order(-nhanes_promedio_peso_x_etnia_adultos$Weight), ]\n\n\n# Redondear el peso a 2 decimales\nnhanes_promedio_peso_x_etnia_adultos$Weight &lt;- round(\n  nhanes_promedio_peso_x_etnia_adultos$Weight, \n  2\n)\n\n# Desplegar el conjunto de datos\ndatatable(\n  nhanes_promedio_peso_x_etnia_adultos,\n  caption = \"Promedio de peso (kg) por grupo étnico.\",\n  rownames = FALSE,\n  options = list(\n    paging = FALSE,\n    searching = FALSE,\n    info = FALSE,\n    language = list(url = '//cdn.datatables.net/plug-ins/1.10.11/i18n/Spanish.json')\n  )    \n)\n\n\n\n\n\n\n\n\n\n2.4.2.4 Visualizar\nSe presentan tres ejemplos de visualizaciones.\n\n2.4.2.4.1 Promedio de estatura de personas adultas por sexo\n\n\nCódigo\n# Gráfico de barras\nbarplot(\n  nhanes_promedio_estatura_x_sexo_adultos$Height, \n  names.arg = nhanes_promedio_estatura_x_sexo_adultos$Gender, \n  col = \"skyblue\", \n  main = \"Promedio de estatura de personas adultas por sexo\",\n  xlab = \"Sexo\",\n  ylab = \"Estatura promedio (cm)\",\n  las = 0\n)\n\n\n\n\n\n\n\n\n\n\n\n2.4.2.4.2 Promedio de peso de personas adultas por grupo étnico\n\n\nCódigo\n# Gráfico de barras\nbarplot(\n  nhanes_promedio_peso_x_etnia_adultos$Weight,\n  names.arg = nhanes_promedio_peso_x_etnia_adultos$Race3, \n  col = \"skyblue\", \n  main = \"Promedio de peso de personas adultas por grupo étnico\",\n  xlab = \"Grupo étnico\",\n  ylab = \"Peso promedio (kg)\",\n  las = 0\n)\n\n\n\n\n\n\n\n\n\n\n\n2.4.2.4.3 Relación entre estatura y peso de personas adultas hispanas\n\n\nCódigo\n# Subconjunto de personas adultas hispanas\nnhanes_adultos_hispanos &lt;- subset(nhanes_adultos, Race3 == \"Hispanic\")\n\n# Gráfico de dispersión\nplot(\n  nhanes_adultos_hispanos$Height,\n  nhanes_adultos_hispanos$Weight,\n  main = \"Relación entre estatura y peso de personas adultas hispanas\", \n  xlab = \"Estatura (cm)\",\n  ylab = \"Peso (kg)\",\n  pch = 19,\n  col = \"blue\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n2.4.2.5 Modelar\n\n2.4.2.5.1 Predicción del peso a partir de la estatura en personas adultas hispanas\nEl proceso de modelar se ilustra mediante un modelo de regresión lineal.\n\n\nCódigo\n# Ajustar el modelo de regresión\nmodelo_peso_estatura &lt;- lm(Weight ~ Height, data = nhanes_adultos_hispanos)\n\n# Gráfico de dispersión\nplot(\n  nhanes_adultos_hispanos$Height,\n  nhanes_adultos_hispanos$Weight,\n  main = \"Relación entre estatura y peso de personas adultas hispanas\", \n  xlab = \"Estatura (cm)\",\n  ylab = \"Peso (kg)\",\n  pch = 19,\n  col = \"blue\"\n)\n\n# Línea de tendencia del modelo\nabline(\n  modelo_peso_estatura,\n  col = \"red\",\n  lwd = 2\n)\n\n\n\n\n\n\n\n\n\nEl siguiente es un resumen estadístico del modelo.\n\n\nCódigo\n# Desplegar un resumen estadístico del modelo\nsummary(modelo_peso_estatura)\n\n\n\nCall:\nlm(formula = Weight ~ Height, data = nhanes_adultos_hispanos)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-35.945 -10.921  -1.856   8.031  69.213 \n\nCoefficients:\n             Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept) -62.43629   11.16381  -5.593 3.46e-08 ***\nHeight        0.85528    0.06838  12.509  &lt; 2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 15.5 on 573 degrees of freedom\n  (41 observations deleted due to missingness)\nMultiple R-squared:  0.2145,    Adjusted R-squared:  0.2131 \nF-statistic: 156.5 on 1 and 573 DF,  p-value: &lt; 2.2e-16\n\n\nEste resumen nos dice que la estatura es un predictor significativo del peso, pero el modelo deja mucha variación sin explicar. Para una mejor predicción, se podría considerar añadir otras variables (edad, sexo, condición física, etc.).\nPodemos utilizar el modelo para predecir estaturas de personas adultas hispanas a partir de su peso.\n\n\nCódigo\n# Ejemplo de predicciones para nuevas alturas\nnuevas_estaturas &lt;- data.frame(Height = c(150, 160, 170))\npredicciones &lt;- predict(modelo_peso_estatura, newdata = nuevas_estaturas)\n\n# Mostrar las predicciones\ndata.frame(\n  Estatura = nuevas_estaturas$Height,\n  Peso_predicho = round(predicciones, 2)\n)\n\n\n  Estatura Peso_predicho\n1      150         65.86\n2      160         74.41\n3      170         82.96\n\n\n\n\n\n2.4.2.6 Comunicar\nLa comunicación puede realizarse de muchas maneras. Por ejemplo, a través de una página web desarrollada en Quarto, que incluya los datos, el código fuente y los resultados, como es el caso de este documento.",
    "crumbs": [
      "I Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introducción a la ciencia de datos</span>"
    ]
  },
  {
    "objectID": "02-introduccion-ciencia-datos.html#referencias",
    "href": "02-introduccion-ciencia-datos.html#referencias",
    "title": "2  Introducción a la ciencia de datos",
    "section": "2.5 Referencias",
    "text": "2.5 Referencias\n\n\nÇetinkaya-Rundel, M., & Hardin, J. (2021). Introduction to\nModern Statistics (1st ed.). OpenIntro,\nInc. Retrieved from https://openintro-ims.netlify.app/\n\n\nWickham, H., Çetinkaya-Rundel, M., & Grolemund, G. (2023). R for\nData Science: Import,\nTidy, Transform, Visualize, and\nModel Data (2nd ed.). O’Reilly Media.\nRetrieved from https://r4ds.hadley.nz/",
    "crumbs": [
      "I Introducción a la programación de computadoras y a la ciencia de datos",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introducción a la ciencia de datos</span>"
    ]
  },
  {
    "objectID": "03-r.html",
    "href": "03-r.html",
    "title": "3  R - lenguaje de programación para análisis estadístico",
    "section": "",
    "text": "3.1 Resumen\nEn este capítulo se introduce el lenguaje de programación R, sus tipos de datos, sus estructuras de control y sus funciones para generación de gráficos estadísticos.\nR es un lenguaje de programación y un entorno para graficación y análisis estadístico. Como lenguaje, es interpretado, multiplataforma, de tipado dinámico y multiparadigma. Es un proyecto de software libre que se comparte mediante una licencia GNU GPL.\nEl código de R se estructura en funciones, las cuales pueden distribuirse en paquetes. Cada paquete contiene un conjunto de funciones relacionadas. Algunos paquetes están incorporados en la instalación base de R y otros deben instalarse separadamente.\nLa instación base de R incluye una gran variedad de funciones que permiten crear gráficos estadísticos como diagramas de dispersión, histogramas y gráficos de barras, entre otros.\nR puede manejar diversos tipos de datos básicos, como números, textos y valores lógicos, entre otros. También tipos de datos compuestos, como factores y data frames. Al igual que otros lenguajes de programación, cuenta con estructuras de control como condicionales y ciclos.",
    "crumbs": [
      "II El lenguaje de programación R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R - lenguaje de programación para análisis estadístico</span>"
    ]
  },
  {
    "objectID": "03-r.html#trabajo-previo",
    "href": "03-r.html#trabajo-previo",
    "title": "3  R - lenguaje de programación para análisis estadístico",
    "section": "3.2 Trabajo previo",
    "text": "3.2 Trabajo previo\n\n3.2.1 Lecturas\nChang, Winston (2018). R graphics cookbook: Practical recipes for visualizing data (2nd ed.) (capítulo 2). O’Reilly. https://r-graphics.org/\nGrolemund, G., & Wickham, H. (2014). Hands-On Programming with R: Write Your Own Functions And Simulations (capítulos 1 - 12). O’Reilly Media. https://rstudio-education.github.io/hopr/",
    "crumbs": [
      "II El lenguaje de programación R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R - lenguaje de programación para análisis estadístico</span>"
    ]
  },
  {
    "objectID": "03-r.html#introducción",
    "href": "03-r.html#introducción",
    "title": "3  R - lenguaje de programación para análisis estadístico",
    "section": "3.3 Introducción",
    "text": "3.3 Introducción\nR es un lenguaje de programación y un entorno enfocado en graficación y en análisis estadístico. Fue creado por Ross Ihaka y Robert Gentleman en la Universidad de Auckland, Nueva Zelanda, en 1993. Es ampliamente utilizado en diversas áreas de investigación, entre las que pueden mencionarse aprendizaje automático (machine learning), ciencia de datos (data science) y big data, con aplicaciones en campos como agricultura, biomedicina, bioinformática, finanzas, hidrología, teledetección y geografía entre muchos otros.\nAlgunas de las principales características del lenguaje de programación R son:\n\nEs interpretado: las instrucciones se traducen una por una a lenguaje máquina, a diferencia de los lenguajes compilados, que traducen de manera conjunta las instrucciones de una unidad completa (ej. un programa o una biblioteca). Los lenguajes interpretados tienden a ser más lentos que los compilados, pero también son más flexibles.\nEs multiplataforma: puede ejecutarse en los sistemas operativos más populares (ej. Microsoft Windows, macOS, Linux).\nTiene un sistema de tipos de datos dinámico: las variables pueden tomar diferentes tipos de datos (ej. textuales, numéricos) durante la ejecución del programa, a diferencia del caso de un sistema de tipos de datos estático, en el que las variables de un programa solo pueden tener un tipo de datos.\nSoporta varios paradigmas de programación: los paradigmas son estilos o enfoques teóricos de programación. R soporta los paradigmas de programación funcional, programación orientada a objetos, programación imperativa y programación procedimental.\n\nR es un proyecto de software libre que se comparte mediante una licencia GNU General Public Licence (GNU GPL). Esta característica permite que la funcionalidad original de R pueda ser ampliada mediante bibliotecas o paquetes desarrollados por la comunidad de programadores.\nLa Comprehensive R Archive Network (CRAN) es una red mundial distribuida de servidores que albergan el código y la documentación oficial de R y sus paquetes. Las tasks views de CRAN categorizan la funcionalidad de R de acuerdo con temáticas determinadas.\nPara escribir programas en R puede utilizarse una interfaz de línea de comandos, un editor de texto (ej. Visual Studio Code) o un ambiente de desarrollo integrados (IDE, en inglés Integrated Development Environment) como RStudio.",
    "crumbs": [
      "II El lenguaje de programación R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R - lenguaje de programación para análisis estadístico</span>"
    ]
  },
  {
    "objectID": "03-r.html#el-ambiente-de-desarrollo-integrado-rstudio",
    "href": "03-r.html#el-ambiente-de-desarrollo-integrado-rstudio",
    "title": "3  R - lenguaje de programación para análisis estadístico",
    "section": "3.4 El ambiente de desarrollo integrado RStudio",
    "text": "3.4 El ambiente de desarrollo integrado RStudio\nRStudio es el IDE más popular para el lenguaje R. Está disponible en una versión de escritorio (RStudio Desktop) y en una versión para servidor (RStudio Server). Esta última permite la conexión de varios usuarios a través de un navegador web. RStudio se ofrece también como un servicio en la nube, a través de Posit Cloud. La Figura 3.1 muestra la interfaz de RStudio.\n\n\n\n\n\n\nFigura 3.1: Interfaz del ambiente de desarrollo integrado RStudio.\n\n\n\nAdemás de edición de código fuente, RStudio contiene capacidades para depurar código y visualizar datos en formatos tabulares, gráficos y de mapas.\nEjercicios\n\nInstale en su computadora:\n\nSistema base del lenguaje R.\n\nRStudio Desktop.\n\nCree un usuario en Posit Cloud, para así poder usar RStudio en la nube.\nCree un programa (script) de R en RStudio (con la opción de menú File - New File - R Script) y escriba y ejecute el código utilizado en el capítulo anterior para generar un gráfico que muestre el promedio de estatura de personas adultas por sexo.",
    "crumbs": [
      "II El lenguaje de programación R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R - lenguaje de programación para análisis estadístico</span>"
    ]
  },
  {
    "objectID": "03-r.html#conceptos-fundamentales",
    "href": "03-r.html#conceptos-fundamentales",
    "title": "3  R - lenguaje de programación para análisis estadístico",
    "section": "3.5 Conceptos fundamentales",
    "text": "3.5 Conceptos fundamentales\n\n3.5.1 Representación de datos\n\n3.5.1.1 Objetos\nEn R, prácticamente todo se maneja a través de objetos. Un objeto es cualquier entidad que se guarda en memoria y que R puede reconocer, manipular y procesar. Por ejemplo, un vector, una matriz, un data frame, una lista o incluso una función, son todos objetos en R. Los objetos en R pueden ser de muchos tipos, algunos básicos como números, caracteres y lógicos y otros compuestos como matrices y listas que permiten manejar varios valores conjuntamente.\nPor ejemplo, el siguiente bloque de código crea un objeto de tipo vector con el operador de asignación &lt;-. Un vector es una secuencia de elementos del mismo tipo.\n\n# Crear un vector de números primos\nprimos &lt;- c(2, 3, 5, 7, 11)\n\n# Mostrar el vector\nprint(primos)\n\n[1]  2  3  5  7 11\n\n\nPor su parte, una matriz es una estructura de datos bidimensional en la que todos los elementos deben ser del mismo tipo, al igual que en un vector. Una matriz puede considerarse una colección de vectores organizados en filas y columnas.\n\n# Crear vectores\nv1 &lt;- c(1, 2, 3)\nv2 &lt;- c(4, 5, 6)\n\n# Combinar vectores como columnas de una matriz\nm &lt;- cbind(v1, v2)\n\n# Mostrar la matriz\nprint(m)\n\n     v1 v2\n[1,]  1  4\n[2,]  2  5\n[3,]  3  6\n\n\nUno de los tipos de objetos fundamentales en R para el manejo y análisis de datos es el data frame. Un data frame es una estructura rectangular de filas y columnas, similar a una tabla de datos (ej. las de las hojas de cálculo), en la que cada fila corresponde a una observación y cada columna a una variable. Las columnas pueden ser de diferentes tipos: números, caracteres, lógicos y muchos otros. Las columnas (o las filas) de un data frame pueden considerarse vectores, todos del mismo tamaño.\n\n# Crear vectores\npeso &lt;- c(70, 65, 80, 55, 90)         # en kilogramos\nestatura &lt;- c(1.75, 1.68, 1.82, 1.60, 1.90)  # en metros\n\n# Crear dataframe\nmedidas &lt;- data.frame(peso, estatura)\n\n# Mostrar el dataframe\nprint(medidas)\n\n  peso estatura\n1   70     1.75\n2   65     1.68\n3   80     1.82\n4   55     1.60\n5   90     1.90\n\n\nLas columnas de un data frame pueden retornarse como vectores mediante el operador $.\n\n# Columna (vector) correspondiente a la estatura\nmedidas$peso\n\n[1] 70 65 80 55 90\n\n\nLos data frames permiten realizar operaciones sobre los datos como creación de subconjuntos, ordenamientos, filtrados, cálculos estadísticos (promedio, desviación estándar, mínimo, máximo, etc.) y muchas otras.\nLos vectores, las matrices y los data frames se estudiarán con más detalle en este capítulo junto con otros tipos y estructuras de datos de R.\n\n\n3.5.1.2 Conjuntos de datos para ejemplos y pruebas\nPara efectos de pruebas y ejemplos, la distribución base de R incorpora varios conjuntos de datos que pueden listarse con la función data(). Para obtener información acerca de un conjunto de datos en particular, puede utilizarse el operador ?.\n\n# Información sobre todos los conjuntos de datos incorporados en la distribución base de R\ndata()\n\n# Información sobre el cojunto de datos \"cars\"\n?cars\n\n# Información sobre el cojunto de datos \"mtcars\"\n?mtcars\n\n# Información sobre el cojunto de datos \"iris\"\n?iris\n\n# Visualización de iris\nView(iris)\n\nAdemás, existen muchos sitios en Internet que brindan acceso a conjuntos de datos que pueden utilizarse para pruebas. Por ejemplo:\n\nKaggle - conjuntos de datos\nBanco Mundial - indicadores\n\n\n\n\n3.5.2 Funciones\n\n3.5.2.1 Concepto\nR, al igual que otros lenguajes de programación, estructura su funcionalidad en unidades de código fuente llamadas funciones. Cada función realiza una tarea específica como, por ejemplo, un cálculo matemático o el procesamiento de una hilera de texto.\nUna función tiene un nombre y, opcionalmente, un conjunto de argumentos que especifican los datos de entrada que procesa la función. Los argumentos se escriben entre paréntesis redondos (()) y estos siempre deben incluirse, aún en el caso de que la función no tenga ningún argumento. Si la función tiene varios argumentos, deben separarse mediante comas (,). Por lo general, las funciones retornan un valor como salida.\n\n\n3.5.2.2 Ejemplos\nLa función print() recibe como argumento un valor (ej. un texto o un número) para imprimirlo en la pantalla. En el siguiente fragmento de código en R, se utiliza print() para imprimir la hilera “Hola mundo”. Nótese el uso del símbolo # para comentarios (i.e. texto que no es código ejecutable).\n\n# Impresión de una hilera de caracteres\nprint(\"Hola mundo\")\n\n[1] \"Hola mundo\"\n\n\nLa función mean() retorna la media aritmética del argumento de entrada. En el siguiente ejemplo, se calcula la media de los números de un vector creado a su vez con la función c().\n\n# Media aritmética\nmean(c(2, 4, 5, 9))\n\n[1] 5\n\n\nLa función getwd() (get working directory) retorna la ruta del directorio de trabajo de la sesión actual de R. Este es el directorio en el cual R espera encontrar, por ejemplo, archivos de datos.\n\n# Impresión del directorio de trabajo\ngetwd()\n\n[1] \"/home/rstudio/2025-i\"\n\n\nLa función setwd() (set working directory) establece la ruta del directorio de trabajo de la sesión actual de R. Como argumento, recibe una hilera de texto con la ruta.\nNote las barras utilizadas para separar los subdirectorios: / (no \\)\n\n# Especificación del directorio de trabajo (la ruta debe existir)\nsetwd(\"C:/Users/mfvargas\")\n\nEjercicios\n\nObtenga la ruta de su directorio de trabajo con la función getwd() y anótela.\n\nCambie la ruta de su directorio de trabajo con la función setwd() a cualquier otro directorio en el que tenga derechos de escritura. Verifique el cambio usando nuevamente getwd().\n\nCon la función create.file(), cree un archivo llamado hola.R y escriba ahí el programa “Hola mundo”: cat(\"Hola mundo\")\n\nEjecute su programa con los botones Run y Source de RStudio.\n\nCambie nuevamente su directorio de trabajo a la ruta que anotó en el paso 1. Copie ahí su programa y ejecútelo nuevamente.\n\n\n\n3.5.2.3 Argumentos\nLos argumentos de las funciones tienen nombres que pueden especificarse, en caso de ser necesario, al llamar la función. Los nombres de los argumentos de una función pueden omitirse cuando el orden y la posición de esos argumentos son suficientes para identificarlos. Si se desea cambiar el orden o que el código sea más claro, se pueden indicar los nombres de los argumentos.\nEn el siguiente ejemplo, se utilizan los argumentos x, xlab y ylab de la función plot(), de la instalación básica de R, para especificar la fuente de datos y las etiquetas de los ejes x e y de un gráfico de dispersión.\n\n# Gráfico de dispersón del conjunto de datos \"cars\" con etiquetas en los ejes x e y\nplot(\n  x=cars$speed,\n  y=cars$dist,\n  xlab=\"Velocidad (mph)\", \n  ylab=\"Distancia requerida para frenar (pies)\"\n)\n\n\n\n\n\n\n\n\nEjercicios\n\nEstudie la documentación de la función plot() y agregue al gráfico anterior:\n\nUn título.\n\nUn subtítulo.\n\n\n\n\n3.5.2.4 Ayuda\nPara obtener ayuda sobre una función desde la línea de comandos de R, puede utilizarse un signo de pregunta (?) seguido del nombre de la función o bien la función help(). Por ejemplo:\n\n# Ayuda de la función setwd()\n?setwd\nhelp(setwd)\n\nTambién puede utilizarse la función apropos(), para buscar funciones por palabras clave.\n\n# Búsqueda, por palabras clave, de funciones relacionadas con \"mean\" (media aritmética). Note las comillas (\"\").\napropos(\"mean\")\n\n [1] \".colMeans\"     \".rowMeans\"     \"colMeans\"      \"kmeans\"       \n [5] \"mean\"          \"mean.Date\"     \"mean.default\"  \"mean.difftime\"\n [9] \"mean.POSIXct\"  \"mean.POSIXlt\"  \"rowMeans\"      \"weighted.mean\"\n\n\nLa función example() presenta ejemplos sobre el uso de una función.\n\n# Ejemplos de uso de la función mean()\nexample(\"mean\")\n\n\nmean&gt; x &lt;- c(0:10, 50)\n\nmean&gt; xm &lt;- mean(x)\n\nmean&gt; c(xm, mean(x, trim = 0.10))\n[1] 8.75 5.50\n\n\nPor otra parte, el sitio All R Documentation reúne documentación de funciones de una gran cantidad de paquetes de R.\nTambién puede obtenerse ayuda en buscadores de Internet, como Google, o en sitios de preguntas y respuestas para programadores, como Stack Overflow.\n\n\n\n3.5.3 Paquetes\nLas funciones de R se distribuyen en paquetes. Cada paquete contiene un conjunto de funciones relacionadas. También hay paquetes que contienen datos (ej. los resultados de un censo).\nPara utilizar un paquete, primero debe cargarse (en la memoria del computador) con la función library().\n\n# Carga del paquete stats\nlibrary(stats)\n\nAlgunos paquetes están contenidos en la distribución base de R. Otros deben instalarse con la función install.packages().\nEn el siguiente ejemplo, se instala el paquete titanic, el cual contiene información sobre los pasajeros durante el viaje inaugural del transatlántico RMS Titanic, resumida según el estatus económico (clase), sexo, edad y supervivencia de cada pasajero.\n\n# Instalación del paquete titanic (note las comillas)\ninstall.packages(\"titanic\")\n\nSeguidamente, el paquete titanic se carga con la función library().\n\n# Carga de titanic\nlibrary(titanic)\n\n\n\n3.5.4 Visualización de datos\n\n3.5.4.1 La función View()\nEl conjunto de datos titanic_train puede observarse, con sus observaciones y variables, con la función View(), la cual permite visualizar un conjunto de datos en una tabla.\n\n# Visualización del conjunto de datos titanic_train\nView(titanic_train)\n\nEste conjunto de datos se utiliza para entrenar modelos de aprendizaje automático (machine learning) para que realicen predicciones (ej. la supervivencia o muerte de un pasajero con base en variables como edad, clase, sexo y otras). Las predicciones del modelo se evalúan con titanic_test, el conjunto de datos de evaluación.\n\n\n3.5.4.2 Funciones básicas de graficación estadística\nLa instalación básica de R, la cual incluye el paquete base y el paquete graphics, ofrece una gran variedad de funciones para elaborar gráficos estadísticos. Esta funcionalidad se enriquece gracias al aporte de paquetes elaborados por terceros, los cuales se estudiarán posteriormente en este curso. Entre los tipos de gráficos que pueden elaborarse con la instalación básica de R están los gráficos de dispersión, los gráficos de barras, los gráficos de pastel y los histogramas.\n\n3.5.4.2.1 Gráficos de barras\nUn gráfico de barras permite representar variables de un conjunto de datos mediante barras rectangulares de longitud proporcional a los valores representados. Los gráficos de barras se utilizan principalmente para representar datos que involucran variables categóricas. Permiten comparar fácilmente cantidades o números asociados a diferentes categorías. Por ejemplo, se puede usar un gráfico de barras para mostrar la cantidad de ventas de diferentes tipos de productos, la población en diferentes ciudades, o las puntuaciones obtenidas por estudiantes en diferentes materias.\nEl siguiente gráfico de barras muestra la cantidad de pasajeros por clase en titanic_train, mediante la función barplot(), una de las funciones de graficación básica de R. Esta función recibe como argumento los valores que se desea representar en las barras, por lo que antes se utiliza la función table() para generar una tabla de contingencia con las cantidades de pasajeros que viajaban en cada clase.\n\n# Cantidades de pasajeros por clase\npasajeros_por_clase &lt;- table(titanic_train$Pclass)\n\n# Despliegue\npasajeros_por_clase\n## \n##   1   2   3 \n## 216 184 491\n\n\n# Gráfico de barras por clase de pasajero\nbarplot(\n  height = pasajeros_por_clase,\n  main = \"Cantidad de pasajeros por clase en el Titanic\",\n  xlab = \"Clase\",\n  ylab = \"Cantidad de pasajeros\"  \n)\n\n\n\n\n\n\n\n\nLa cantidad de pasajeros en cada clase puede subdividirse en fallecidos y sobrevivientes.\n\n# Cantidades de pasajeros fallecidos y sobrevivientes por clase\n# (0 corresponde a fallecidos y 1 a sobrevivientes)\npasajeros_por_clase_sobrevivencia &lt;- \n  table(titanic_train$Survived, titanic_train$Pclass)\n\n# Despliegue\npasajeros_por_clase_sobrevivencia\n##    \n##       1   2   3\n##   0  80  97 372\n##   1 136  87 119\n\nEl siguiente gráfico de barras apiladas muestra la distribución de pasajeros sobrevivientes y fallecidos en cada clase.\n\n# Gráfico de barras apiladas\nbarplot(\n  height = pasajeros_por_clase_sobrevivencia,\n  main = \"Cantidad de pasajeros fallecidos y sobrevivientes por clase\",\n  xlab = \"Clase\",\n  ylab = \"Cantidad de pasajeros\",\n  col = topo.colors(2)\n)\n\n# Leyenda\nlegend(\n  x = \"topleft\",\n  inset = 0.03,\n  legend = c(\"Fallecidos\", \"Sobrevivientes\"),\n  fill = topo.colors(2),\n  horiz = TRUE\n)\n\n\n\n\n\n\n\n\nLa misma información se muestra seguidamente en un gráfico de barras agrupadas. Note el uso del argumento beside.\n\n# Gráfico de barras agrupadas\nbarplot(\n  height = pasajeros_por_clase_sobrevivencia,\n  main = \"Cantidad de pasajeros fallecidos y sobrevivientes por clase\",\n  xlab = \"Clase\",\n  ylab = \"Cantidad de pasajeros\",  \n  col = topo.colors(2),\n  beside = TRUE\n)\n\n# Leyenda\nlegend(\n  x = \"topleft\",\n  inset = 0.03,\n  legend = c(\"Fallecidos\", \"Sobrevivientes\"),\n  fill = topo.colors(2),\n  horiz = TRUE\n)\n\n\n\n\n\n\n\n\n\n\n3.5.4.2.2 Gráficos de pastel\nLos gráficos de pastel se utilizan para mostrar proporciones o porcentajes, representando la composición de un todo. Son especialmente útiles para resaltar cómo se divide un conjunto en categorías, donde cada segmento del pastel (slice o “rebanada”) representa la proporción o porcentaje de esa categoría dentro del total. Por lo tanto, son más adecuados para visualizar datos categóricos o cualitativos, no para datos numéricos continuos.\nLa cantidad de pasajeros por clase en titanic_train también puede mostrarse en un gráfico de pastel, mediante la función pie de la instalación básica de R.\n\n# Gráfico de pastel por clase de pasajero\npie(\n  x = pasajeros_por_clase, \n  main = \"Distribución de pasajeros por clase en el Titanic\",\n  labels = paste(names(pasajeros_por_clase), \":\", pasajeros_por_clase)\n)\n\n\n\n\n\n\n\n\n\n\n3.5.4.2.3 Histogramas\nUn histograma es una representación gráfica de la distribución de una variable numérica en forma de barras (en este caso, llamadas en inglés bins). La longitud de cada barra representa la frecuencia de un rango de valores de la variable.\nEn la instalación básica de R, los histogramas se implementan mendiante la función hist().\n\nhist(\n  x = titanic_train$Age, \n  breaks = 8,\n  main = \"Distribución de la edad de los pasajeros del Titanic\", \n  xlab = \"Edad\", \n  ylab = \"Frecuencia\"\n)\n\n\n\n\n\n\n\n\nEjercicios\n\nMuestre la distribución de pasajeros fallecidos y sobrevivientes por sexo en un gráfico de barras apiladas.\n\nMuestre la distribución de pasajeros fallecidos y sobrevivientes por sexo en un gráfico de barras agrupadas.\nGuarde los gráficos en un archivo PDF (puede consultar Saving plots to a file with pdf(), jpeg() and png()).\n\n\n\n\n\n3.5.5 Manipulación de datos\nEn esta sección se estudian varias operaciones para manipular data frames mediante la sintaxis y las funciones base de R:\n\nCreación de subconjuntos.\nOrdenamiento.\nCreación y modificación de columnas.\nAgrupación y sumarización.\n\nPara ilustrar las operaciones, se utiliza el conjunto de datos Netflix Movies and TV Shows.\n\n# Importar el CSV desde el repositorio del curso en GitHub\nnetflix &lt;- read.csv(\n  file = \"https://raw.githubusercontent.com/gf0604-procesamientodatosgeograficos/2025-i/refs/heads/main/datos/netflix/netflix_titles.csv\"\n)\n\n\n3.5.5.1 Creación de subconjuntos\nA esta operación se le llama también “filtrado de datos”. Se implementa con la sintaxis dataframe[filas, columnas].\nLas filas y las columnas pueden especificarse mediante vectores, como en los siguientes ejemplos.\n\n# Subconjunto de las 5 primeras filas y todas las columnas\nprimeras_filas &lt;- netflix[1:5, ]\n\n# Despliegue\nprint(primeras_filas)\n\n  show_id    type                 title        director\n1      s1   Movie  Dick Johnson Is Dead Kirsten Johnson\n2      s2 TV Show         Blood & Water                \n3      s3 TV Show             Ganglands Julien Leclercq\n4      s4 TV Show Jailbirds New Orleans                \n5      s5 TV Show          Kota Factory                \n                                                                                                                                                                                                                                                                                                             cast\n1                                                                                                                                                                                                                                                                                                                \n2 Ama Qamata, Khosi Ngema, Gail Mabalane, Thabang Molaba, Dillon Windvogel, Natasha Thahane, Arno Greeff, Xolile Tshabalala, Getmore Sithole, Cindy Mahlangu, Ryle De Morny, Greteli Fincham, Sello Maake Ka-Ncube, Odwa Gwanya, Mekaila Mathys, Sandi Schultz, Duane Williams, Shamilla Miller, Patrick Mofokeng\n3                                                                                                                                                             Sami Bouajila, Tracy Gotoas, Samuel Jouy, Nabiha Akkari, Sofia Lesaffre, Salim Kechiouche, Noureddine Farihi, Geert Van Rampelberg, Bakary Diombera\n4                                                                                                                                                                                                                                                                                                                \n5                                                                                                                                                                                                        Mayur More, Jitendra Kumar, Ranjan Raj, Alam Khan, Ahsaas Channa, Revathi Pillai, Urvi Singh, Arun Kumar\n        country         date_added release_year rating  duration\n1 United States September 25, 2021         2020  PG-13    90 min\n2  South Africa September 24, 2021         2021  TV-MA 2 Seasons\n3               September 24, 2021         2021  TV-MA  1 Season\n4               September 24, 2021         2021  TV-MA  1 Season\n5         India September 24, 2021         2021  TV-MA 2 Seasons\n                                                      listed_in\n1                                                 Documentaries\n2               International TV Shows, TV Dramas, TV Mysteries\n3 Crime TV Shows, International TV Shows, TV Action & Adventure\n4                                        Docuseries, Reality TV\n5        International TV Shows, Romantic TV Shows, TV Comedies\n                                                                                                                                               description\n1 As her father nears the end of his life, filmmaker Kirsten Johnson stages his death in inventive and comical ways to help them both face the inevitable.\n2      After crossing paths at a party, a Cape Town teen sets out to prove whether a private-school swimming star is her sister who was abducted at birth.\n3       To protect his family from a powerful drug lord, skilled thief Mehdi and his expert team of robbers are pulled into a violent and deadly turf war.\n4      Feuds, flirtations and toilet talk go down among the incarcerated women at the Orleans Justice Center in New Orleans on this gritty reality series.\n5 In a city of coaching centers known to train India’s finest collegiate minds, an earnest but unexceptional student and his friends navigate campus life.\n\n\n\n# Subconjunto de las 5 primeras filas y las 3 primeras columnas\nprimeras_filas &lt;- netflix[1:5, 1:3]\n\n# Despliegue\nprint(primeras_filas)\n\n  show_id    type                 title\n1      s1   Movie  Dick Johnson Is Dead\n2      s2 TV Show         Blood & Water\n3      s3 TV Show             Ganglands\n4      s4 TV Show Jailbirds New Orleans\n5      s5 TV Show          Kota Factory\n\n\n\n# Subconjunto de las 5 primeras filas y \n# las columnas show_id, type, title, director y country\nprimeras_filas &lt;- netflix[\n  1:5, \n  c(\"show_id\", \"type\", \"title\", \"director\", \"country\")\n]\n\n# Despliegue\nprint(primeras_filas)\n\n  show_id    type                 title        director       country\n1      s1   Movie  Dick Johnson Is Dead Kirsten Johnson United States\n2      s2 TV Show         Blood & Water                  South Africa\n3      s3 TV Show             Ganglands Julien Leclercq              \n4      s4 TV Show Jailbirds New Orleans                              \n5      s5 TV Show          Kota Factory                         India\n\n\nLas filas a filtrar también pueden especificarse mediante expresiones lógicas.\n\n# Películas dirigidas por Clint Eastwood\neastwood &lt;- netflix[\n  netflix$director == \"Clint Eastwood\", \n  c(\"show_id\", \"type\", \"title\", \"director\", \"release_year\")\n]\n\n# Despliegue\nprint(eastwood)\n\n     show_id  type                  title       director release_year\n351     s351 Movie          Space Cowboys Clint Eastwood         2000\n800     s800 Movie    Million Dollar Baby Clint Eastwood         2004\n820     s820 Movie The Outlaw Josey Wales Clint Eastwood         1976\n943     s943 Movie           Mystic River Clint Eastwood         2003\n6889   s6889 Movie            Gran Torino Clint Eastwood         2008\n7092   s7092 Movie               Invictus Clint Eastwood         2009\n7127   s7127 Movie            Jersey Boys Clint Eastwood         2014\n\n\nNótese el uso de $ para especificar la columna y del operador de comparación == (igualdad).\n\n# Películas dirigidas por Clint Eastwood y estrenadas a partir del año 2000\neastwood_2000 &lt;- netflix[\n  netflix$director == \"Clint Eastwood\" & netflix$release_year &gt;= 2000, \n  c(\"show_id\", \"type\", \"title\", \"director\", \"release_year\")\n]\n\n# Despliegue\nprint(eastwood_2000)\n\n     show_id  type               title       director release_year\n351     s351 Movie       Space Cowboys Clint Eastwood         2000\n800     s800 Movie Million Dollar Baby Clint Eastwood         2004\n943     s943 Movie        Mystic River Clint Eastwood         2003\n6889   s6889 Movie         Gran Torino Clint Eastwood         2008\n7092   s7092 Movie            Invictus Clint Eastwood         2009\n7127   s7127 Movie         Jersey Boys Clint Eastwood         2014\n\n\nEl operador lógico & (AND) especifica que ambas expresiones lógicas deben cumplirse (ser verdaderas).\n\n\n3.5.5.2 Ordenamiento\nLa función order() permite ordenar un data frame según una o varias columnas, al retornar los índices de las filas en el orden deseado.\n\n# Ordenar las películas dirigidas por Clint Eastwood\n# por orden descendente de año de estreno\neastwood_ordenado &lt;- eastwood[\n  order(eastwood$release_year, decreasing = TRUE), \n]\n\n# Despliegue\nprint(eastwood_ordenado)\n\n     show_id  type                  title       director release_year\n7127   s7127 Movie            Jersey Boys Clint Eastwood         2014\n7092   s7092 Movie               Invictus Clint Eastwood         2009\n6889   s6889 Movie            Gran Torino Clint Eastwood         2008\n800     s800 Movie    Million Dollar Baby Clint Eastwood         2004\n943     s943 Movie           Mystic River Clint Eastwood         2003\n351     s351 Movie          Space Cowboys Clint Eastwood         2000\n820     s820 Movie The Outlaw Josey Wales Clint Eastwood         1976\n\n\n\n\n3.5.5.3 Creación y modificación de columnas\nEn un data frame, una columna puede crearse o modificarse con los operadores $ y &lt;-.\n\n# Vector de valores de sexo\nvector_sexo &lt;- c(\n  \"mujer\", \"hombre\", \"mujer\", \"mujer\", \"mujer\", \"hombre\", \"mujer\", \"hombre\", \"hombre\", \"hombre\"\n)\n\n# Vector de peso en kilogramos\nvector_peso_kg &lt;- c(\n  51.0, 98.5, 91.6, 60.6, 59.1, 59.2, 65.2, 76.2, 71.6, 64.6\n)\n\n# Definir un data frame\npersonas &lt;- data.frame(\n  sexo = vector_sexo,\n  peso_kg = vector_peso_kg\n)\n\n# Agregar una nueva columna para el peso en libras\npersonas$peso_lb &lt;- personas$peso_kg * 2.205\n\n# Despliegue\nprint(personas)\n\n     sexo peso_kg  peso_lb\n1   mujer    51.0 112.4550\n2  hombre    98.5 217.1925\n3   mujer    91.6 201.9780\n4   mujer    60.6 133.6230\n5   mujer    59.1 130.3155\n6  hombre    59.2 130.5360\n7   mujer    65.2 143.7660\n8  hombre    76.2 168.0210\n9  hombre    71.6 157.8780\n10 hombre    64.6 142.4430\n\n\n\n\n3.5.5.4 Agrupación y sumarización\nLa distribución base de R permite agrupar y sumarizar datos de varias formas.\nPor ejemplo, la función table() cuenta la cantidad de filas correspondientes a cada valor de una variable categórica.\n\n# Cantidad de películas o series por clasificación\nnetflix_conteo_x_clasificacion &lt;- table(netflix$rating)\n\n# Despliegue\nprint(netflix_conteo_x_clasificacion)\n\n\n           66 min   74 min   84 min        G    NC-17       NR       PG \n       4        1        1        1       41        3       80      287 \n   PG-13        R    TV-14     TV-G    TV-MA    TV-PG     TV-Y    TV-Y7 \n     490      799     2160      220     3207      863      307      334 \nTV-Y7-FV       UR \n       6        3 \n\n\nLa tabla que retorna table() puede convertirse a un data frame con la función as.data.frame() para ordenarse o procesarse de alguna otra forma.\n\n# Convertir a data frame\nnetflix_conteo_x_clasificacion_df &lt;- as.data.frame(\n  x = netflix_conteo_x_clasificacion\n)\n\n# Renombrar las columnas\nnames(netflix_conteo_x_clasificacion_df) &lt;- c(\n  \"rating\", \"count\"\n)\n\n# Ordenar\nnetflix_conteo_x_clasificacion_df_ordenado &lt;- netflix_conteo_x_clasificacion_df[\n  order(netflix_conteo_x_clasificacion_df$count, decreasing = TRUE),\n]\n\n# Despliegue de las 10 clasificaciones más frecuentes\nprint(netflix_conteo_x_clasificacion_df_ordenado[1:10, ])\n\n   rating count\n13  TV-MA  3207\n11  TV-14  2160\n14  TV-PG   863\n10      R   799\n9   PG-13   490\n16  TV-Y7   334\n15   TV-Y   307\n8      PG   287\n12   TV-G   220\n7      NR    80\n\n\nPor su parte, la función aggregate() calcula estadísticas (ej. promedios, mínimos, máximos) para grupos formados con base en los valores de una o varias variables categóricas.\n\n# Promedio de peso en kg por sexo\npromedio_estatura_x_sexo &lt;- aggregate(\n  data = personas,\n  peso_kg ~ sexo,\n  FUN = mean,\n  na.rm = TRUE # para eliminar valores NA (vacíos)\n)\n\n# Despliegue\nprint(promedio_estatura_x_sexo)\n\n    sexo peso_kg\n1 hombre   74.02\n2  mujer   65.50\n\n\nLa “fórmula” peso_kg ~ sexo se utiliza para indicar cómo se deben agrupar los datos:\n\nEl símbolo ~ se lee como “en función de”.\nA la izquierda está la variable dependiente (peso_kg), la que se quiere resumir o analizar.\nA la derecha está la variable independiente (sexo), la que se usa para agrupar.\n\n\n\n3.5.5.5 Ejemplo\nEl siguiente programa ejemplifica algunas de las funciones de manipulación de datos y graficación de la distribución base de R. En las salidas, se utilizan las funciones pdf() y dev.off() para almacenar los gráficos en un archivo PDF.\n#\n# Análisis de datos de la Encuesta Nacional de Salud y Nutrición (NHANES)\n#\n\n# ENTRADA\n\n# Importar datos de NHANES (National Health and Nutrition Examination Survey)\nnhanes &lt;- read.csv(\n  file = \"https://raw.githubusercontent.com/gf0604-procesamientodatosgeograficos/2025-i/refs/heads/main/datos/nchs/nhanes.csv\"\n)\n\n\n# PROCESAMIENTO\n\n# 1. Obtener cantidades de personas por nivel de educación formal\n\n# Agrupar y contar por nivel de educación formal\ncantidad_x_educacion &lt;- table(nhanes$Education)\n\n# Convertir a data frame\ncantidad_x_educacion &lt;- as.data.frame(\n  cantidad_x_educacion\n)\n\n# Renombrar las columnas\nnames(cantidad_x_educacion) &lt;- c(\"educacion\", \"cantidad\")\n\n# Ordenar por cantidad\ncantidad_x_educacion &lt;- cantidad_x_educacion[\n  order(cantidad_x_educacion$c, decreasing = TRUE),\n]\n\n# 2. Obtener datos de estatura y peso de mujeres\n\n# Filtrar datos de estatura y peso de mujeres\nmujeres &lt;- nhanes[nhanes$Gender == \"female\", c(\"Height\", \"Weight\")]\n\n\n# SALIDA\n\n# Abrir archivo PDF\npdf(\"analisis-nhanes-graficos.pdf\", width = 12, height = 6)\n# Márgenes (arriba, izquierda, abajo, derecha)\npar(mar = c(4, 7, 4, 2))\n\n# 1. Gráfico de barras: Cantidad de personas por nivel de educación formal\nbarplot(\n  height = cantidad_x_educacion$cantidad,\n  names.arg = cantidad_x_educacion$educacion,\n  main = \"Cantidad de personas por nivel de educación formal\",\n  xlab = \"Nivel de educación formal\",\n  ylab = \"Cantidad de personas\",\n  las = 1,\n  cex.names = 0.9,\n  col = \"black\"\n)\n\n# 2. Gráfico de dispersión: estatura vs. peso de mujeres\nplot(\n  x = mujeres$Height,\n  y = mujeres$Weight,\n  main = \"Estatura vs. peso de mujeres\",\n  xlab = \"Estatura (cm)\",\n  ylab = \"Peso (kg)\",\n  pch = 19,\n  col = \"red\"\n)\n\n# Cerrar archivo PDF\ndev.off()\n\n\n\n3.5.6 Tipos de datos\nR puede trabajar con varios tipos de datos básicos, entre los que están números, caracteres (i.e. textos) y lógicos. También puede trabajar con tipos compuestos, como factores y data frames.\nComo se mencionó, R proporciona acceso a los datos a través de objetos. Un objeto es una entidad que tiene asociadas propiedades (i.e. datos) y métodos (i.e. funciones) para manipular esas propiedades. Un objeto puede ser, por ejemplo, un número, una hilera de texto, un vector o una matriz. R también permite que el programador defina sus propios objetos.\nHay muchas formas de crear objetos en R. Una de las más sencillas es con los operadores de asignación. Estos son = y &lt;- (o -&gt;). Por ejemplo, las siguientes sentencias crean un número, un texto y un vector.\n\n# Número\nx &lt;- 10\nx\n## [1] 10\n\n# Otro número\n20 -&gt; y\ny\n## [1] 20\n\n# Hilera de caracteres\nnombre &lt;- 'Manuel'\nnombre\n## [1] \"Manuel\"\n\n# Vector de hileras de caracteres\ndias &lt;- c('Domingo', 'Lunes', 'Martes', 'Miércoles', 'Jueves', 'Viernes', 'Sábado')\ndias\n## [1] \"Domingo\"   \"Lunes\"     \"Martes\"    \"Miércoles\" \"Jueves\"    \"Viernes\"  \n## [7] \"Sábado\"\n\nTanto x, como nombre como dias son variables. Una variable es una etiqueta que se le asigna a un objeto. Una variable debe comenzar con una letra.\nEl tipo de un objeto puede consultarse con la función typeof(). Por ejemplo:\n\ntypeof(x)\n## [1] \"double\"\ntypeof(y)\n## [1] \"double\"\ntypeof(nombre)\n## [1] \"character\"\ntypeof(dias)\n## [1] \"character\"\n\nA continuación, se describen con más detalle algunos de los tipos de datos utilizados en el lenguaje R.\n\n3.5.6.1 Tipos básicos\nR define seis tipos de datos básicos. En esta sección, se describen los más utilizados durante este curso.\n\n3.5.6.1.1 Números\nPueden ser enteros (integer) o decimales (double). Se utilizan en diversos tipos de operaciones, incluyendo las aritméticas (ej. suma, resta, multiplicación, división).\n\n# Declaración de variables numéricas\nx &lt;- 5\ny &lt;- 0.5\n\n# Suma\nx + y\n## [1] 5.5\n\n# Tipos de datos numéricos\ntypeof(x)\n## [1] \"double\"\ntypeof(y)\n## [1] \"double\"\ntypeof(x + y)\n## [1] \"double\"\n\nNótese que al declararse una variable numérica, ya sea que tenga o no punto decimal, R la considera por defecto de tipo double. Para que se considere de tipo integer, debe utilizarse el sufijo L o la función as.integer().\n\n# Números enteros\nx &lt;- 10L\ny &lt;- as.integer(15)\n\n# Multiplicación\nx * y\n## [1] 150\n\n# Tipos de datos enteros\ntypeof(x)\n## [1] \"integer\"\ntypeof(y)\n## [1] \"integer\"\ntypeof(x * y)\n## [1] \"integer\"\n\n\n\n3.5.6.1.2 Caracteres\nSe utilizan para representar textos. Deben estar entre comillas simples ('') o dobles (\"\").\n\n# Hileras de caracteres\nnombre &lt;- \"María\"\napellido &lt;- \"Pérez\"\n\n# Concatenación mediante la función paste()\npaste(nombre, apellido)\n## [1] \"María Pérez\"\n\n\n\n3.5.6.1.3 Lógicos\nLos objetos lógicos (también llamados booleanos) tienen dos posibles valores: verdadero (TRUE) o falso (FALSE).\n\n# Variable lógica\na &lt;- 1 &lt; 2\na\n## [1] TRUE\n\n# Variable lógica\nb &lt;- 1 &gt; 2\nb\n## [1] FALSE\n\nLas expresiones lógicas pueden combinarse con operadores como:\n\n& (Y, en inglés AND)\n| (O, en inglés OR)\n! (NO, en inglés NOT)\n\n\n# Operador lógico AND\n(1 &lt; 2) & (3 &lt; 4)\n## [1] TRUE\n\n# Operador lógico OR\n(2 + 2 == 5) | (20 &lt;= 10)\n## [1] FALSE\n\n# Operador lógico NOT\n!(2 + 2 == 5)\n## [1] TRUE\n\n\n\n3.5.6.1.4 Vectores\nUn vector es una estructura unidimensional que combina objetos del mismo tipo.\n\n3.5.6.1.4.1 Definición\nLos vectores pueden definirse de varias formas como, por ejemplo, con la función c() (del inglés combine):\n\n# Definición de un vector de números\nvector_numeros &lt;- c(1, 7, 32, 45, 57)\nvector_numeros\n## [1]  1  7 32 45 57\n\n# Definición de un vector de hileras de caracteres\nvector_nombres &lt;- c(\"Álvaro\", \"Ana\", \"Berta\", \"Bernardo\")\nvector_nombres\n## [1] \"Álvaro\"   \"Ana\"      \"Berta\"    \"Bernardo\"\n\nLos vectores también pueden crearse con el operador :, el cual especifica una secuencia (i.e. una lista ordenada):\n\n# Definición de un vector de números con la secuencia de 1 a 10\nvector_secuencia &lt;- 1:10\nvector_secuencia\n##  [1]  1  2  3  4  5  6  7  8  9 10\n\n# Definición de un vector de números con la secuencia de -5 a 5\nvector_secuencia &lt;- -5:5\nvector_secuencia\n##  [1] -5 -4 -3 -2 -1  0  1  2  3  4  5\n\n# Definición de un vector de números con la secuencia de -0.5 a 3.7\nvector_secuencia &lt;- -0.5:3.7\nvector_secuencia\n## [1] -0.5  0.5  1.5  2.5  3.5\n\nLa función seq() también crea un vector con base en una secuencia y permite especificar argumentos como un valor de incremento y la longitud de la secuencia.\n\n# Definición de un vector de números en secuencia de 1 a 10\nvector_secuencia &lt;- seq(1, 10)\nvector_secuencia\n##  [1]  1  2  3  4  5  6  7  8  9 10\n\n# Definición de un vector de números en secuencia de 0.5 a 15.3, con incremento de 2\nvector_secuencia &lt;- seq(from=0.5, to=15.3, by=2)\nvector_secuencia\n## [1]  0.5  2.5  4.5  6.5  8.5 10.5 12.5 14.5\n\n# Definición de un vector de números en secuencia de 1.5 a 9.4, con longitud de 4\nvector_secuencia &lt;- seq(from=1.5, to=9.4, length.out=4)\nvector_secuencia\n## [1] 1.500000 4.133333 6.766667 9.400000\n\n\n\n3.5.6.1.4.2 Indexación\nLos elementos de un vector se acceden a través de sus índices (i.e. posiciones). La primera posición corresponde al índice 1, la segunda al índice 2 y así sucesivamente. Los índices se especifican entre paréntesis cuadrados ([]), ya sea para una posición específica o para un rango de posiciones. También es posible especificar los índices que se desea excluir.\n\n# Vector de nombres de países\npaises &lt;- c(\"Argentina\", \"Francia\", \"China\", \"Australia\", \"México\")\npaises\n## [1] \"Argentina\" \"Francia\"   \"China\"     \"Australia\" \"México\"\n\n# Elemento en el índice 3\npaises[3]\n## [1] \"China\"\n\nEl operador : puede utilizarse para especificar un rango de índices:\n\n# Elementos entre los índices 2 y 4 (2, 3 y 4)\npaises[2:4]\n## [1] \"Francia\"   \"China\"     \"Australia\"\n\nCon la función c(), es posible especificar un conjunto de índices particulares:\n\n# Elementos entre los índices 1, 4 y 5\npaises[c(1, 4, 5)]\n## [1] \"Argentina\" \"Australia\" \"México\"\n\nLos números negativos pueden usarse para excluir índices:\n\n# Exclusión de los índices 3 y 4\npaises[c(-3, -4)]\n## [1] \"Argentina\" \"Francia\"   \"México\"\n\nLos valores lógicos TRUE y FALSE también pueden usarse para incluir y excluir índices de un vector:\n\n# Se incluyen los índices 1, 2 y 4; y se excluyen los índices 3 y 5\npaises[c(TRUE, TRUE, FALSE, TRUE, FALSE)]\n## [1] \"Argentina\" \"Francia\"   \"Australia\"\n\n\n\n3.5.6.1.4.3 Operaciones\nEn los vectores pueden aplicarse operaciones aritméticas:\n\na &lt;- c(1, 3, 5, 7)\nb &lt;- c(2, 4, 6, 8)\n\n# Suma de vectores\na + b\n## [1]  3  7 11 15\n\n# Multiplicación de vectores\na * b\n## [1]  2 12 30 56\n\nY también pueden realizarse operaciones relacionales:\n\n# Comparación con el operador &lt;\na &lt; b\n## [1] TRUE TRUE TRUE TRUE\n\n\n\n\n3.5.6.1.5 Matrices\nUna matriz es una estructura bidimensional de filas y columnas.\n\n3.5.6.1.5.1 Definición\nLas matrices se definen mediante la función matrix().\n\n# Definición de una matriz de 3 x 3 con elementos de la secuencia 1:9 distribuidos en las columnas\nm &lt;- matrix(1:9, nrow=3, ncol=3)\nm\n##      [,1] [,2] [,3]\n## [1,]    1    4    7\n## [2,]    2    5    8\n## [3,]    3    6    9\n\n# Definición de una matriz de 3 x 3 con elementos de la secuencia 1:9 distribuidos en las filas\nm &lt;- matrix(1:9, nrow=3, ncol=3, byrow=TRUE)\nm\n##      [,1] [,2] [,3]\n## [1,]    1    2    3\n## [2,]    4    5    6\n## [3,]    7    8    9\n\n# Definición de una matriz de 3 x 2 con nombres para las filas y las columnas\ndatos &lt;- c(18, 500, 25, 1000, 30, 2000)\nfilas &lt;- c(\"Ana\", \"Mario\", \"Laura\")\ncolumnas &lt;- c(\"Edad\", \"Salario\")\n\nm &lt;- matrix(datos, nrow=3, ncol=2, byrow=TRUE, dimnames=list(filas, columnas))\nm\n##       Edad Salario\n## Ana     18     500\n## Mario   25    1000\n## Laura   30    2000\n\nLa función list() se utiliza, en este caso, para combinar vectores. En general, se usa para combinar datos de cualquier tipo.\n\n\n3.5.6.1.5.2 Indexación\nLa indexación de matrices es similar a la de vectores, pero deben especificarse índices tanto para filas como para columnas.\n\n# Elemento en la posición [2,2] (segunda fila, segunda columna)\nm[2, 2]\n## [1] 1000\n\n# Elementos de la primera fila\nm[1,]\n##    Edad Salario \n##      18     500\n\n# Elementos de la segunda columna\nm[, 2]\n##   Ana Mario Laura \n##   500  1000  2000\n\n# Elementos de las filas 1 y 2\nm[1:2, ]\n##       Edad Salario\n## Ana     18     500\n## Mario   25    1000\n\n# Elementos de la fila \"Mario\"\nm[\"Mario\", ]\n##    Edad Salario \n##      25    1000\n\n# Elementos de la columna \"Salario\"\nm[, \"Salario\"]\n##   Ana Mario Laura \n##   500  1000  2000\n\n\n\n3.5.6.1.5.3 Operaciones\nDe manera similar a los vectores, en las matrices pueden realizarse operaciones aritméticas y relacionales.\n\na &lt;- matrix(1:4, nrow=2, ncol=2)\na\n##      [,1] [,2]\n## [1,]    1    3\n## [2,]    2    4\n\nb &lt;- matrix(5:8, nrow=2, ncol=2)\nb\n##      [,1] [,2]\n## [1,]    5    7\n## [2,]    6    8\n\n# Suma de matrices\na + b\n##      [,1] [,2]\n## [1,]    6   10\n## [2,]    8   12\n\n# Multiplicación de matrices\na * b\n##      [,1] [,2]\n## [1,]    5   21\n## [2,]   12   32\n\n# Comparación de matrices con el operador &gt;\na &gt; b\n##       [,1]  [,2]\n## [1,] FALSE FALSE\n## [2,] FALSE FALSE\n\n\n\n\n\n3.5.6.2 Tipos compuestos\n\n3.5.6.2.1 Data Frames\nUn data frame es una estructura bidimensional similar a lo que comúnmente se conoce como una tabla. Sus filas corresponden a las observaciones de un conjunto de datos y sus columnas a las variables. Internamente, se componen de varios vectores, factores y/o matrices de la misma longitud. La definición de un data frame puede incluir nombres para cada observación y para cada variable. Los data frames implementan un conjunto de funciones similares a las de una hoja electrónica o una tabla de una base de datos relacional. Son fundamentales para el manejo de datos en R.\n\n3.5.6.2.1.1 Definición\nLa función data.frame() crea un data frame a partir de vectores que serán las columnas del data frame.\n\n# Vector de nombres de países\npaises &lt;-\n  c(\"Panamá\",\n    \"Costa Rica\",\n    \"Nicaragua\",\n    \"El Salvador\",\n    \"Honduras\",\n    \"Guatemala\",\n    \"Belice\")\n\n# Vector de cantidades de habitantes de cada país (en millones)\npoblaciones &lt;- c(4.1, 5.0, 6.2, 6.4, 9.2, 16.9, 0.3)\n\n# Creación de un data frame a partir de los dos vectores\npoblaciones_paises &lt;- \n  data.frame(\n    pais = paises, \n    poblacion = poblaciones\n  )\n\n# Impresión del data frame\npoblaciones_paises\n##          pais poblacion\n## 1      Panamá       4.1\n## 2  Costa Rica       5.0\n## 3   Nicaragua       6.2\n## 4 El Salvador       6.4\n## 5    Honduras       9.2\n## 6   Guatemala      16.9\n## 7      Belice       0.3\n\n\n\n3.5.6.2.1.2 Indexación\nLos datos de un data frame pueden accederse principalmente de dos formas. La primera es mediante la misma sintaxis [fila, columna] que se utiliza en las matrices.\n\n# Fila 1\npoblaciones_paises[1, ]\n##     pais poblacion\n## 1 Panamá       4.1\n\n# Filas 1, 5 y 7\npoblaciones_paises[c(1, 5, 7), ]\n##       pais poblacion\n## 1   Panamá       4.1\n## 5 Honduras       9.2\n## 7   Belice       0.3\n\n# Columna 2\npoblaciones_paises[, 2]\n## [1]  4.1  5.0  6.2  6.4  9.2 16.9  0.3\n\n# Fila 1, columna 2\npoblaciones_paises[1, 2]\n## [1] 4.1\n\n# Filas 1:4, columna 2\npoblaciones_paises[1:4, 2]\n## [1] 4.1 5.0 6.2 6.4\n\nAdemás, mediante el operador $, es posible acceder a las columnas (i.e. variables) del data frame.\n\n# Columna de nombres de países\npoblaciones_paises$pais\n## [1] \"Panamá\"      \"Costa Rica\"  \"Nicaragua\"   \"El Salvador\" \"Honduras\"   \n## [6] \"Guatemala\"   \"Belice\"\n\n# Modificación de los valores de toda una columna\npoblaciones_paises_2 &lt;- poblaciones_paises # copia del dataframe original\npoblaciones_paises_2$poblacion = poblaciones_paises$poblacion*2\npoblaciones_paises_2\n##          pais poblacion\n## 1      Panamá       8.2\n## 2  Costa Rica      10.0\n## 3   Nicaragua      12.4\n## 4 El Salvador      12.8\n## 5    Honduras      18.4\n## 6   Guatemala      33.8\n## 7      Belice       0.6\n\nLa notación de paréntesis cuadrados ([]) y el signo de dólar ($) también permite crear subconjuntos con base en expresiones lógicas.\n\n# Ejemplos de uso de la notación $\n\n# Países con población mayor a 6 millones de habitantes\npoblaciones_paises[poblaciones_paises$poblacion &gt; 6,]\n\n         pais poblacion\n3   Nicaragua       6.2\n4 El Salvador       6.4\n5    Honduras       9.2\n6   Guatemala      16.9\n\n\n\n\n3.5.6.2.1.3 Operaciones\nR proporciona una gran variedad de funciones para manejar data frames. Las siguientes son algunas de las más utilizadas.\nLa función read.table() lee los datos contenidos en un archivo de texto y los retorna en un data frame. read.csv() es una función derivada, con valores por defecto orientados a los archivos de valores separados por comas (CSV, Comma Separated Values). Como argumento principal, read.csv() recibe la ruta del archivo CSV, el cual puede encontrarse en un disco local, en la Web o en otra ubicación.\n\n# Lectura de archivo CSV ubicado en la Web\ncovid &lt;-\n  read.csv(\n    \"https://raw.githubusercontent.com/pf0953-programacionr/2022-ii/main/datos/cepredenac/covid/covid-20210422.csv\"\n  )\n\n# Despliegue de los datos del data frame\ncovid\n##          pais fallecidos recuperados activos positivos\n## 1      Panamá       6198      351949    3845    361992\n## 2  Costa Rica       3125      199779   32370    235274\n## 3   Guatemala       7345      194075   16725    218145\n## 4    Honduras       4981       77020  121358    203359\n## 5 El Salvador       2089       64208    1864     68161\n## 6      Belice        318       12164     114     12596\n## 7   Nicaragua        181        5212      57      5450\n\nLa función str() despliega la estructura de un data frame u otro objeto R.\n\n# Estructura del data frame\nstr(poblaciones_paises)\n\n'data.frame':   7 obs. of  2 variables:\n $ pais     : chr  \"Panamá\" \"Costa Rica\" \"Nicaragua\" \"El Salvador\" ...\n $ poblacion: num  4.1 5 6.2 6.4 9.2 16.9 0.3\n\n\nLa función summary() proporciona un resumen de los contenidos de un data frame:\n\n# Resumen de los contenidos del data frame\nsummary(poblaciones_paises)\n\n     pais             poblacion     \n Length:7           Min.   : 0.300  \n Class :character   1st Qu.: 4.550  \n Mode  :character   Median : 6.200  \n                    Mean   : 6.871  \n                    3rd Qu.: 7.800  \n                    Max.   :16.900  \n\n\nLa función View() invoca un visor de datos que permite visualizar un objeto R en un formato de tabla en una hoja de cálculo. Ejecute en su computadora la siguiente línea de código para apreciar el funcionamiento de View().\n\n# Vista de los casos de COVID-19\nView(covid, \"Casos de COVID-19 en Centramérica\")\n\n\n\n\n3.5.6.2.2 Factores\nLos factores se utilizan para representar datos categóricos. Un factor corresponde a un conjunto de categorías correspondientes a un concepto (ej. [“Sí”, “No”], [“Casado”, “Soltero”], [“Alto”, “Medio”, “Bajo”]).\nInternamente, los factores se representan en R como números enteros con etiquetas asociadas. A pesar de que los factores parecen (y pueden funcionar como) hileras de caracteres, en realidad son números y debe tenerse cuidado de no manejarlos como caracteres.\nLos elementos de un factor se denominan niveles (levels) y, por defecto, se almacenan en orden alfabético.\n\n3.5.6.2.2.1 Definición\nUn factor se crea con la función factor().\n\n# Factor de valores de sexo\nsexo &lt;- factor(c(\"Masculino\", \"Femenino\", \"Femenino\", \"Masculino\"))\n\n\n\n3.5.6.2.2.2 Operaciones\nR proporciona una gran variedad de funciones para manejar factores. Seguidamente, se ejemplifican algunas de estas.\n\n# Etiquetas de los niveles\nlevels(sexo)\n## [1] \"Femenino\"  \"Masculino\"\n\n# Cantidad de niveles\nnlevels(sexo)\n## [1] 2\n\n# Conteo de elementos de cada uno de los niveles del factor\ntable(sexo)\n## sexo\n##  Femenino Masculino \n##         2         2\n\n\n\n\n\n3.5.6.3 Otros\n\n3.5.6.3.1 Fechas\nLas fechas se manejan en R mediante un tipo especial que permite realizar operaciones como diferencias, agrupamientos y otras. Internamente, una fecha en R se almacena como un número que representa la cantidad de días transcurridos desde el 1 de enero de 1970 (1970-01-01).\n\n3.5.6.3.1.1 Operaciones\nLa función Sys.Date() retorna la fecha actual.\n\n# Fecha actual\nfecha_actual &lt;- Sys.Date()\nfecha_actual\n## [1] \"2025-06-03\"\n\n# Tipo de datos\ntypeof(fecha_actual)\n## [1] \"double\"\n\n# Clase\nclass(fecha_actual)\n## [1] \"Date\"\n\nLa función as.Date() convierte datos entre los tipos fecha y carácter, de acuerdo con un formato. El formato que se usa por defecto (y el recomendado) es el que corresponde a la norma ISO 8601 (ej. 2023-12-03), pero pueden emplearse otros también.\n\n# Conversión de fecha en formato año-mes-día\nfecha_caracter_01 &lt;- \"2020-01-01\"\nfecha_01 &lt;- as.Date(fecha_caracter_01, format=\"%Y-%m-%d\")\nfecha_01\n\n[1] \"2020-01-01\"\n\n# Conversión de fecha en formato día/mes/año\nfecha_caracter_02 &lt;- \"31/01/2020\"\nfecha_02 &lt;- as.Date(fecha_caracter_02, format=\"%d/%m/%Y\")\nfecha_02\n\n[1] \"2020-01-31\"\n\n# Diferencia entre fechas\nfecha_02 - fecha_01\n\nTime difference of 30 days\n\n\nHay una lista de formatos de fechas en Date Formats in R - R-bloggers.\n\n\n\n\n\n3.5.7 Definición de funciones\nAdemás de todas las funciones disponibles en la distribución base de R y en sus diferentes paquetes, R permite que los programadores definan sus propias funciones.\nToda función tiene tres partes esenciales:\n\nUn nombre.\nUn conjunto de argumentos.\nUn conjunto de líneas de código, también llamado el cuerpo de la función.\n\nPara programar una función, debe definirse cada una de esas partes por medio de la palabra reservada function function().\nPor ejemplo, la siguiente función calcula la nota final de un curso con base en los argumentos correspondientes a los promedios de exámenes, proyectos y tareas.\n\n# Función que calcula la nota final de un curso\nnota_final &lt;- function(promedio_examenes,\n                       promedio_proyectos,\n                       promedio_tareas) {\n  factor_examenes &lt;- promedio_examenes * 0.5\n  factor_proyectos &lt;- promedio_proyectos * 0.4\n  factor_tareas &lt;- promedio_tareas * 0.1\n  \n  return(factor_examenes + factor_proyectos + factor_tareas)\n}\n\nLa función return() es la que define el valor de retorno de la función. Si no se incluye, la función retorna la última expresión evaluada.\nAhora que está definida, la función nota_final() puede ser “llamada”, con diferentes argumentos:\n\n# Si ni se incluyen los nombres de los argumentos, \n# la función asume que se ingresan en el mismo orden en el que fueron definidos\nnota_final(100, 50, 0)\n## [1] 70\n\n# El uso de los nombres de argumentos \n# permite modificar su orden\nnota_final(promedio_examenes =  100, promedio_tareas =  0, promedio_proyectos = 50)\n## [1] 70\n\nSi se desea darle al usuario la opción de omitir algunos argumentos, se les puede asignar un valor por defecto.\nSeguidamente, la función nota_final() se redefine asignando valores por defecto a algunos de los argumentos:\n\n# Redefinición de la función nota final,\n# con valores por defecto para los argumentos\nnota_final &lt;- function(promedio_examenes,\n                       promedio_proyectos = 0,\n                       promedio_tareas = 0) {\n  factor_examenes &lt;- promedio_examenes * 0.5\n  factor_proyectos &lt;- promedio_proyectos * 0.4\n  factor_tareas &lt;- promedio_tareas * 0.1\n  \n  # Al no llamarse a la función return(), se retorna la última expresión:\n  factor_examenes + factor_proyectos + factor_tareas\n}\n\n# Se utiliza el valor por defecto (0) para el argumento promedio_tareas\nnota_final(promedio_examenes = 100, promedio_proyectos = 50)\n## [1] 70\n\n# Se llama la función usando la posición del primer argumento y el nombre del segundo\nnota_final(100, promedio_proyectos = 50)\n## [1] 70\n\nEjercicios\n\nDefina una función con nombre celsius_a_fahrenheit() que reciba como argumento una cantidad en grados Celsius y retorne el equivalente en grados Fahrenheit.\n\nDefina una función con nombre fahrenheit_a_celsius() que reciba como argumento una cantidad en grados Fahrenheit y retorne el equivalente en grados Celsius.\n\nDefina una función con nombre imc() para calcular el índice de masa corporal (IMC) de una persona con base en su peso (en kilogramos) y su estatura (en metros).\n\n\n\n3.5.8 Condicionales\nLas sentencias condicionales evalúan una expresión lógica (i.e. condición) y ejecutan, o no, un bloque de intrucciones dependiendo de si la expresión es verdadera (TRUE) o falsa (FALSE). Permiten que los programas “tomen decisiones” y varíen su curso de acción.\nLos condicionales en R se implementa mediante la sentencia if y sus cláusulas else y else if.\n\n3.5.8.1 La sentencia if\nLa sentencia if evalúa una condición (i.e. una expresión lógica) y ejecuta un bloque de instrucciones, si es verdadera. El bloque se delimita con los caracteres de “llaves”: {}.\n\n# Sintaxis de la sentencia if\nif (condicion) {\n  # bloque de instrucciones a ejecutar si la condicion es verdadera\n}\n\nPor ejemplo:\n\n# Edad de una persona\nedad &lt;- 25\n\n# Se utiliza la sentencia if para determinar \n# si la persona es adulta\nif (edad &gt;= 18) {\n  print(\"Adulto\")\n}\n## [1] \"Adulto\"\n\nYa sea que se ejecute o no el bloque del if, el programa continúa con las instrucciones que siguen al bloque, si las hay.\n\n\n3.5.8.2 La cláusula else\nUna sentencia if puede ir seguida de una cláusula else, la cual define un bloque que se ejecuta si la condición es falsa. Por ejemplo:\n\nedad &lt;- 15\n\nif (edad &gt;= 18) {\n  print(\"Adulto\")\n} else {\n  print(\"Menor\")\n}\n\n[1] \"Menor\"\n\n\n\n\n3.5.8.3 La cláusula else if\nUna sentencia if también puede ir seguida de una o varias cláusulas else if, las cuales evalúan condiciones adicionales.\n\nedad &lt;- 70\n\nif (edad &lt; 18) {\n  print(\"Menor\")\n} else if (edad &lt; 65) {\n  print(\"Adulto\")\n} else {\n  print(\"Adulto mayor\")\n}\n\n[1] \"Adulto mayor\"\n\n\nLas cláusulas else if deben escribirse antes de la cláusula else, la cual es siempre la última, si es que está presente. Tanto las cláusulas else if como la cláusula else son opcionales.\nEjercicios\n\nDefina una función con nombre interpretacion_imc() que reciba como argumento un número correspondiente al índice de masa corporal (IMC) de una persona. Debe retornar una hilera de caracteres correspondiente a la interpretación del IMC (“Bajo peso”, “Normal”, “Sobrepeso”, “Obesidad”), de acuerdo con la tabla disponible en Índice de masa corporal - Wikipedia.\n\n\n\n\n3.5.9 Ciclos\nLos ciclos permiten ejecutar tareas de manera repetitiva en un programa. Algunos ciclos se ejecutan una cantidad definida de veces, mientras que otros lo hacen mientras se cumple una condición lógica. Pueden usarse en combinación con sentencias que terminan anticipadamente el ciclo o que omiten algunas de sus iteraciones.\nLos ciclos en R se implementan mediante las sentencias for, while y repeat, en combinación con las sentencias break y next.\nR provee varias funciones que implementan ciclos de manera implícita, tales como apply(), tapply() y lapply(). Adicionalmente, hay muchas operaciones (ej. las aritméticas) que están “vectorizadas”, por lo que no es necesario utilizarlas en ciclos. El uso de código vectorizado es muy recomendado en R, por ser muy eficiente.\n\n3.5.9.1 La sentencia for\nLa sentencia for repite las instrucciones contenidas en un bloque para cada uno de los elementos de un vector o lista. En cada iteración (i.e. cada “vuelta” del ciclo), el valor del elemento que está siendo procesado se almacena en una variable.\n\n# Sintaxis de la sentencia for\nfor (variable in vector) {\n  # bloque de instrucciones\n}\n\nPor ejemplo, el siguiente bloque de código utiliza un ciclo de tipo for para recorrer un vector de nombres e imprimir un saludo para cada uno.\n\n# Vector con nombres de personas\nvector_nombres &lt;- c(\"Andrés\", \"Beatriz\", \"Carlos\", \"Marta\", \"Pedro\", \"Sara\")\n\n# Recorrido del vector\nfor (nombre in vector_nombres) {\n  cat(\"Hola\", nombre, \"\\n\")\n}\n## Hola Andrés \n## Hola Beatriz \n## Hola Carlos \n## Hola Marta \n## Hola Pedro \n## Hola Sara\n\nEn el siguiente ejemplo, se utiliza otro ciclo for para recorrer un vector de números y sumar sus elementos.\n\n# Vector de números\nvector_numeros &lt;- c(29.6, -36.81, 31.85, 25.71, 90.2, 0.4)\n\n# Variable para la suma de los números\nsuma &lt;- 0\n\n# Recorrido del vector\nfor (x in vector_numeros) {\n  suma &lt;- suma + x\n}\n\n# Impresión de la suma\ncat(\"Suma:\", suma)\n## Suma: 140.95\n\nSeguidamente, se utiliza dos for “anidados” para sumar los elementos de cada una de las columnas de una matriz.\n\n# Matriz de números\nmatriz_numeros &lt;- matrix(1:12, nrow=3, ncol=4)\nmatriz_numeros\n##      [,1] [,2] [,3] [,4]\n## [1,]    1    4    7   10\n## [2,]    2    5    8   11\n## [3,]    3    6    9   12\n\n# Ciclo externo para recorrer las columnas de la matriz\nfor (j in 1:ncol(matriz_numeros)) {\n  suma_columna &lt;- 0\n  # Ciclo interno para recorrer las elementos de cada columna\n  for (i in 1:nrow(matriz_numeros)) {\n    suma_columna &lt;- suma_columna + matriz_numeros[i, j]\n  }\n  print(suma_columna)\n}\n## [1] 6\n## [1] 15\n## [1] 24\n## [1] 33\n\nEjercicios\n\nUtilice un ciclo for para recorrer el vector vector_numeros y calcular el promedio de sus elementos.\n\nUtilice dos ciclos for anidados para recorrer la matriz vector_numeros y calcular el promedio de cada una de sus columnas.\n\n\n\n3.5.9.2 La sentencia while\nLa sentencia while evalúa una condición (i.e. una expresión lógica) en cada iteración de un ciclo y ejecuta las intrucciones del bloque mientras la condición sea verdadera. Generalmente, en algún momento la condición se vuelve falsa y así finaliza el ciclo.\n\n# Sintaxis de la sentencia while\nwhile (condicion) {\n  # bloque de instrucciones \n}\n\nEn el siguiente ejemplo, se utiliza un ciclo while para preguntarle al usuario cuál es la respuesta definitiva al sentido de la vida, el universo y todo lo demás y se continúa haciendo la pregunta hasta que responda correctamente:\n\n# Función para leer una respuesta desde la pantalla\nleer_respuesta &lt;- function() {\n  readline(prompt=\"¿Cual es la respuesta definitiva al sentido de la vida, el universo y todo lo demás? \")\n}\n\n# Si la respuesta es incorrecta, se repite la pregunta hasta que el usuario conteste correctamente\nwhile (leer_respuesta() != \"42\") {   \n  print(\"¡Su respuesta es incorrecta!\")\n}\n\nEjercicios\n\nUtilice un ciclo while para implementar el cálculo del promedio de los elementos de un vector. Sugerencia: utilice la función length() para obtener la longitud del vector y así saber cuando terminar de recorrerlo.",
    "crumbs": [
      "II El lenguaje de programación R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R - lenguaje de programación para análisis estadístico</span>"
    ]
  },
  {
    "objectID": "03-r.html#recursos-de-interés",
    "href": "03-r.html#recursos-de-interés",
    "title": "3  R - lenguaje de programación para análisis estadístico",
    "section": "3.6 Recursos de interés",
    "text": "3.6 Recursos de interés\nFind Open Datasets and Machine Learning Projects | Kaggle. (s. f.). Recuperado 24 de abril de 2022, de https://www.kaggle.com/datasets\nIndicators | Data. (s.f.). Recuperado 11 de septiembre de 2022, de https://data.worldbank.org/indicator\nNewest «r» Questions. (s. f.). Stack Overflow. Recuperado 24 de abril de 2022, de https://stackoverflow.com/questions/tagged/r\nPapers with Code—Machine Learning Datasets. (s.f.). Recuperado 11 de septiembre de 2022, de https://paperswithcode.com/datasets\nR Language Definition. (s. f.). Recuperado 24 de abril de 2022, de https://cran.r-project.org/doc/manuals/r-release/R-lang.html\nR Package Documentation. (s.f.). Recuperado 11 de septiembre de 2022, de https://rdrr.io/",
    "crumbs": [
      "II El lenguaje de programación R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R - lenguaje de programación para análisis estadístico</span>"
    ]
  }
]